# 面试题
##### 1. 从1-5随机到1-7随机
> 条件函数f() 返回1-5，求目标函数g()
> 得到函数0-1范围如下：
```cpp
int zeroToOne() {
    random_device rd;
    default_random_engine generator(rd());
    uniform_int_distribution distribution(1, 5);
    int ans = 3;
    while (ans == 3) {
        ans = distribution(generator);
    }
    return ans > 3 ? 1 : 0;
}
```
> 得到函数0-7范围如下：
```cpp
// 得到000-111做到等概率
int zeroToSeven() {
    int ans = (zeroToOne() << 2) + (zeroToOne() << 1) + zeroToOne();
    return ans;
}
```
> 得到1-7范围如下：
```cpp
int oneToSix() {
    int ans = 7;
    // 如果是7重新随机
    while(ans == 7) {
        ans = zeroToSeven();
    }
    // ans [0-6]

    // 返回结果[1-7]
    return ans + 1;
}
```

##### 2. 从a-b随机到c-d随机
> - 从给定f函数做出0-1发生器
> - 0-1发生器找出 d-c 是几位二进制。比如 1-7 范围需要0-6范围+1， 0-6范围需要3个二进制位
> - 由c-d范围做出函数找到 0~（d-c）范围之后+c即可

##### 3. 01不等概率随机到01等概率随机
```cpp
// 不等概率的随机数
int f1() {
    uniform_real_distribution<double> distribution(0, 1);
    double d = distribution(generator);
    return d < 0.85 ? 0 : 1;
}
```
```cpp
// 等概率返回01
int zeroToOneEql(){
    int ans = 0;
    do {
        ans = f1();
    } while (ans == f1());
    // 两次结果不相同的概率相同
    // 0.15 * 0.85 ===> 1 0
    // 0.85 * 0.15 ===> 0 1
    return ans;
}
```

##### 4. LeetCode25. K 个一组翻转链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* start = head;
        ListNode* end = getK(start, k);

        head = end;
        reverse(start, end);

        ListNode* lastEnd = start;
        while(lastEnd->next != nullptr) {
            start = lastEnd->next;
            end = getK(start, k);
            if(end==nullptr)
                return head;
            reverse(start, end);
            lastEnd->next = end;
            lastEnd = start;
        }

        return head;
    }

    ListNode* getK(ListNode* head, int k) {
        while(--k!=0 && head!=nullptr) {
            head = head->next;
        }

        return head;
    }

    void reverse(ListNode* start, ListNode* end) {
        end = end->next;
        ListNode* pre = nullptr;
        ListNode* cur = start;
        ListNode* next = nullptr;
        while(cur != end) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        start->next = end;
    }
};
```

##### 5. LeetCode2. 两数相加
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 找出长短链表
        ListNode* ll = listLength(l1) >= listLength(l2) ? l1 : l2;
        ListNode* sl = (ll==l1) ? l2 : l1;
        ListNode* curL = ll;
        ListNode* curS = sl;
        //分三种情况分析
        ListNode* lastNode = nullptr;
        //1. 长链表和短链表都未到尾部
        int carry = 0;
        int num = 0;
        while(curS != nullptr) {
            num = curS->val + curL->val + carry;
            carry = num / 10;
            curL->val = num % 10;
            lastNode = curL;
            curL = curL->next;
            curS = curS->next;
        }
        //2. 只有长链表
        while(curL != nullptr) {
            num = curL->val + carry;
            carry = num / 10;
            curL->val = num % 10;
            lastNode = curL;
            curL = curL->next;
        }
        //3. 最后结果是否有进位
        if(carry!=0) {
            lastNode->next = new ListNode(1);
        }
        return ll;
    }

    int listLength(ListNode* head) {
        int len = 0;
        while(head != nullptr) {
            len++;
            head = head->next;
        }
        return len;
    }
};
```

##### 6. LeetCode21. 合并两个有序链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(list1==nullptr || list2==nullptr)
            return list1==nullptr ? list2 : list1;

        // 找出小头作为最终返回，不动
        ListNode* head = (list1->val <= list2->val) ? list1 : list2;
        // 准备c1作为较小头链表的第二个节点
        ListNode* c1 = head->next;
        // 准备c2作为较大头链表的第一个节点
        ListNode* c2 = head == list1 ? list2 : list1;
        // pre 作为开始比较的第一个节点初始为head
        // pre 每次更新首先指向下一个小的值，然后移动pre等待下次更新
        ListNode* pre = head;
        while(c1!=nullptr && c2!=nullptr) {
            if(c1->val <= c2->val) {
                pre->next = c1;
                c1 = c1->next;
            }
            else {
                pre->next = c2;
                c2 = c2->next;
            }
            pre = pre->next;
        }
        // 当有一方链表走到末尾
        pre->next = c1==nullptr ? c2: c1;
        
        return head;
    }
};
```

##### 6. 位图
- 一个int 32位可以表示0~31个数
- 好处：压缩空间
- 实现
```cpp
class BitMap{
long* bits;

public:
    BitMap(int max) {
        bits = new long[(max + 64) >> 6];
    }
    ~BitMap() {
        delete[] bits;
    }

    void add(int num) {
        bits[num>>6] |= (1l << (num&63));
    }

    void remove(int num) {
        bits[num>>6] &= ~(1l << (num&63));
    }

    bool contains(int num) {
        return ((bits[num>>6]) & (1l << (num&63))) != 0;
    }
};
```
- 加减乘除
```cpp
int add(int x, int y) {
    int sum = x;
    while(y != 0) {
        // 异或运算,无进位相加
        sum = x ^ y;
        // 与运算找进位，进位信息
        y = (x&y) << 1;
        // 无进位相加信息
        x = sum;
    }
    return sum;
}
```
```cpp
int neg(int x, int y) {
    return add(x, add(~y, 1));
}
```
```cpp

int multi(int x, int y) {
    int ans = 0;
    bool negative = false;

    if ((x < 0 && y > 0) || (x > 0 && y < 0)) {
        negative = true;
    }

    if (x < 0) {
        x = neg(0, x);  // 取负数的绝对值
    }

    if (y < 0) {
        y = neg(0, y);  // 取负数的绝对值
    }

    while (y != 0) {
        if (y & 1) {
            ans = add(ans, x);
        }
        x <<= 1;
        y >>= 1;
    }

    if (negative) {
        ans = neg(0, ans);  // 将结果转换回原来的符号表示
    }

    return ans;
}
```
除法
```cpp
int add(int x, int y) {
    int sum = x;
    while(y != 0) {
        // 异或运算
        sum = x ^ y;
        // 与运算找进位
        y = (x&y) << 1;
        x = sum;
    }
    return sum;
}

int neg(int x, int y) {
    return add(x, add(~y, 1));
}

int mult(int x, int y) {
    int ans = 0;
    bool negative = false;

    if ((x < 0 && y > 0) || (x > 0 && y < 0)) {
        negative = true;
    }

    if (x < 0) {
        x = neg(0, x);  // 取负数的绝对值
    }

    if (y < 0) {
        y = neg(0, y);  // 取负数的绝对值
    }

    while (y != 0) {
        if (y & 1) {
            ans = add(ans, x);
        }
        x <<= 1;
        y >>= 1;
    }

    if (negative) {
        ans = neg(0, ans);  // 将结果转换回原来的符号表示
    }

    return ans;
}

bool isNeg(int n) {
    return n < 0;
}

int divi(int a, int b) {
    int x = isNeg(a) ? neg(0, a) : a;
    int y = isNeg(b) ? neg(0, b) : b;
    int res = 0;

    for(int i = 30; i>=0; i=neg(i, 1)) {
        if ((x>>i) >= y) {
            res |= (1<<i);
            x = neg(x, y << i);
        }
    }
    return isNeg(a) ^ isNeg(b) ? neg(0, res) : res;

}

// 处理所有情况
// 尤其包含系统最小值INT_MIN这种情况，因为INT_MIN的绝对值比INT_MAX大1
int divide(int x, int y) {
    // 如果2个都是系统最小值返回1
    if(x==INT_MIN && y==INT_MIN)
        return 1;
    // 如果y是系统最小值返回0
    else if(y==INT_MIN)
        return 0;
    // 如果x是系统最小值
    else if(x==INT_MIN) {
        if(y==neg(0, 1))
            return INT_MAX;
        else {
            int c = divi(add(x, 1), y);
            return add(c, divi(neg(x, mult(c, y)), y));
        }
    }
    // 两个都不是系统最小值
    else {
        return divi(x, y);
    }
}
```
##### 7.LeetCode23
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* myFun(vector<ListNode*>& lists) {
        if(lists.size()==0) return nullptr;
        vector<ListNode*> newLists;
        bool flag = false;
        for(int i=0; i<lists.size(); ++i) {
            if(lists[i]!=nullptr) {
                newLists.push_back(lists[i]);
                flag = true;
            }
        }
        if(flag==false) return nullptr;


        multiset<int> mset;

        for(int i=0; i<newLists.size(); ++i) {
            ListNode* head = newLists[i];
            while(head!=nullptr) {
                mset.insert(head->val);
                head = head->next;
            }
        }
        ListNode* head = new ListNode(*mset.begin());
        ListNode* res = head;
        auto it = mset.begin();
        it++;
        for(; it!=mset.end(); ++it) {
            head->next = new ListNode(*it);
            head = head->next;
        }

        return res;
    }
    struct compNode {
        bool operator()(ListNode* n1, ListNode* n2) {
            return n1->val > n2->val;  // 使用 > 来实现最小堆
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size()==0) return nullptr;

        priority_queue<ListNode*, vector<ListNode*>, compNode> minHeap;

        for(int i=0; i<lists.size(); ++i) {
            if(lists[i]!=nullptr) {
                minHeap.push(lists[i]);
            }
        }
        if(minHeap.empty()) return nullptr;
        
        ListNode* head = minHeap.top();
        ListNode* res = head;
        minHeap.pop();
        if(head->next != nullptr)
            minHeap.push(head->next);

        while(!minHeap.empty()) {
            head->next = minHeap.top();
            head = head->next;
            minHeap.pop();
            if(head->next != nullptr)
                minHeap.push(head->next);
        }
        return res;
        // return myFun(lists);
    }
};
```
---
1. 与运算（AND）：
- 任何数与 0 进行与运算，结果都为 0。
- 任何数与 -1（全1） 进行与运算，结果不变。

2. 或运算（OR）：
- 任何数与 0 进行或运算，结果不变。
- 任何数与 -1（全1） 进行或运算，结果为 -1（全1）。

3. 非运算（NOT）：
- 0 取非运算，结果为 -1（全1）。
- -1（全1）取非运算，结果为 0。

4. 异或运算（XOR）：
- 任何数与自身进行异或运算，结果为 0。
- 任何数与 0 进行异或运算，结果不变。
- 异或运算满足交换律和结合律。

##### 8.LeetCode100
```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==nullptr ^ q==nullptr)
            return false;
        if(p==nullptr && q==nullptr)
            return true;

        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

##### 9. leetcode101
```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return isSame(root, root);
    }

    bool isSame(TreeNode* r1, TreeNode* r2) {
        if(r1==nullptr ^ r2==nullptr)
            return false;
        if(r1==nullptr && r2==nullptr)
            return true;

        return r1->val==r2->val && isSame(r1->left, r2->right) && isSame(r1->right, r2->left);
    }
};
```
##### 10. leetcode104
```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;


        return depth(root, 1);
    }

    int depth(TreeNode* root, int d) {
        if(root->left==nullptr && root->right==nullptr)
            return d;

        int l=0, r=0;
        if(root->left)
            l = depth(root->left, d+1);
        // l = 2;
        if(root->right)
            r = depth(root->right, d+1);

        return l>=r ? l : r;
    }
};
```

##### 11. leetcode105
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        
    //     return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
    // }

    // TreeNode* build(vector<int>& pre, int preB, int preE, vector<int>& in, int inB, int inE) {
    //     // 防止左树或者右树为空，范围越界
    //     if(preB>preE) return nullptr;
    //     TreeNode* head = new TreeNode(pre[preB]);
    //     if(preB==preE) return head;

    //     int find = inB;
    //     while(in[find]!=pre[preB])
    //         find++;

    //     head->left = build(pre, preB+1, preB+find-inB, in, inB, find-1);
    //     head->right = build(pre, preB+find-inB+1, preE, in, find+1, inE);
    //     return head;
        
    // }

    // 建hashmap省略find循环
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        unordered_map<int, int> map;
        for(int i=0; i<inorder.size(); ++i) {
            map[inorder[i]] = i;
        }
        return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1, map);
    }

    TreeNode* build(vector<int>& pre, int l1, int r1, vector<int>& in, int l2, int r2, unordered_map<int, int>& map) {
        if(l1>r1) return nullptr;
        TreeNode* node = new TreeNode(pre[l1]);
        if(l1==r1) {
            // node->val = pre[l1];
            return node;
        }

        int find = map[pre[l1]];
        node->left = build(pre, l1+1, l1+find-l2, in, l2, find-1, map);
        node->right = build(pre, l1+find-l2+1, r1, in, find+1, r2, map);

        return node;
    }
};
```
##### 12. leetcode107
```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> ans;
        if(root==nullptr) return ans;

        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            vector<int> data;
            while(size--) {
                TreeNode* node = que.front();
                data.push_back(node->val);
                que.pop();
                if(node->left)
                    que.push(node->left);
                if(node->right)
                    que.push(node->right);
            }
            ans.push_back(data);
        }
        reverse(ans.begin(), ans.end());

        return ans;
    }
};
```

##### 13. LeetCode110
```cpp
class Solution {
public:
    struct Info{
        int height;
        bool isBalanced;
        Info(int h, bool i): height(h), isBalanced(i) {}
    };
    bool isBalanced(TreeNode* root) {
        return fun(root).isBalanced;
    }

    Info fun(TreeNode* root) {
        if(root==nullptr) return Info(0, true);

        Info l = fun(root->left);
        Info r = fun(root->right);

        // 当次节点左右返回之后，此节点的高度为左右中最高高度+1
        int height = max(l.height, r.height) + 1;
        bool isBalanced = l.isBalanced && r.isBalanced && abs(l.height-r.height) < 2;

        return Info(height, isBalanced);

    }
};
```

##### 14. leetcode112
```cpp
class Solution {
public:
    bool isSum;
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;

        isSum = false;
        fun(root, targetSum, 0);

        return isSum;
    }

    void fun(TreeNode* root, int sum, int preSum) {
        if(root->left==nullptr && root->right==nullptr) {
            if(root->val+preSum==sum)
                isSum = true;
            return;
        }
        preSum += root->val;
        if(root->left) {
            fun(root->left, sum, preSum);
        }
        // preSum -= root->val;
        if(root->right) {
            fun(root->right, sum, preSum);
        }
    }
};
```

##### 14.leetcode 115
```cpp
class Solution {
public:
    bool isSum;
    vector<vector<int>> res;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(!root) return res;
        vector<int> v;

        fun(root, targetSum, 0, v);

        return res;
    }
    void fun(TreeNode* root, int sum, int preSum, vector<int>& v) {
        if(!root->left && !root->right) {
            // v.push_back(root->val);
            if(root->val + preSum == sum) {
                v.push_back(root->val);
                res.push_back(v);
                v.pop_back();
            }
            return;
        }

        preSum += root->val;
        v.push_back(root->val);
        if(root->left)
            fun(root->left, sum, preSum, v);
        
        if(root->right)
            fun(root->right, sum, preSum, v);
        v.pop_back();
    }
};
```

##### 15.leetcode113
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(!root) return res;
        vector<int> path;

        fun(root, targetSum, 0, path);

        return res;
    }
    void fun(TreeNode* root, int sum, int preSum, vector<int>& path) {
        if(!root->left && !root->right) {
            if(preSum + root->val == sum) {
                path.push_back(root->val);
                res.push_back(path);
                path.pop_back();
            }
        }

        path.push_back(root->val);
        preSum += root->val;

        if(root->left)
            fun(root->left, sum, preSum, path);
        if(root->right)
            fun(root->right, sum, preSum, path);
        path.pop_back();
    }
};
```

##### 16.leetcode912
merge sort
```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        if(nums.size()==1) return nums;

        mergeSort(nums, 0, nums.size()-1);

        return nums;
    }


//==================================================================
    void mergeSort(vector<int>& v, int l, int r) {
        if(l==r) return;

        int m = l + (r-l)/2;

        // 左侧
        mergeSort(v, l, m);
        // 右侧
        mergeSort(v, m+1, r);

        // 排序
        merge(v, l, m, r);
    }

    void merge(vector<int>& v, int l, int m, int r) {
        int p1 = l;
        int p2 = m+1;

        // i作为help下标
        int i = 0;
        vector<int> help(r-l+1);

        while(p1<=m && p2<=r) {
            help[i++] = v[p1] <= v[p2] ? v[p1++] : v[p2++];
        }

        while(p1<=m) {
            help[i++] = v[p1++];
        }
        while(p2<=r) {
            help[i++] = v[p2++];
        }

        for(int j=0; j<help.size(); ++j) {
            v[l + j] = help[j];
        }
    }
};
```

##### 17 Morris遍历
```cpp
void morris(TreeNode* head) {
    if(head==nullptr)
        return head;
    TreeNode* cur = head;
    TreeNode* mostRight = nullptr;
    while(cur) {
        mostRight = cur->left;
        if(mostRight) {
            while(mostRight->right && mostRight->right != cur) {
                mostRight = mostRight->right;
            }
            if(!mostRight->right) {
                mostRight->right = cur;
                cur = cur->left;
                continue;
            }
            else {
                mostRight->right = nullptr;
            }
        }
        cur = cur->right;
    }
}
```
##### 18. 各种排序
1. 选择排序 O(n^2)
2. 冒泡排序 O(n^2)
3. 插入排序 O(n^2)
4. 归并排序 O(n*log(n))

| 排序比较 | 时间复杂度 | 空间复杂度 | 稳定性 |
|:------:|:------:|:------:|:------:|
| 选择排序 | O(n^2^) | O(1) | 不稳定 |
| 冒泡排序 | O(n^2^) | O(1) | 稳定  |
| 插入排序 | O(n^2^) | O(1) | 稳定  |
| 归并排序 | O(n*log(n)) | O(n) | 稳定 |
| **快速排序(随机)** | O(n*log(n)) | O(log(n)) | 不稳定 |
| 堆排序   | O(n*log(n)) | O(1) | 不稳定 |

> 结论: 基于比较的排序
> 时间复杂度没有低于 N*logN
> 在空间复杂度为O(N*logN)时，没有低于O(N)空间复杂度的排序


##### 19. 有序数组二分查找
```cpp
int process(vector<int>& v, int l, int r) {
    if (l==r) return v[l];
    int mid = l + (r-l)>>1;
    int leftMax = process(v, l, mid);
    int rightMax = process(v, mid+1, r);

    return max(leftMax，rightMax);
}
```


##### 20. 异或
1. 136. 只出现一次的数字
   
2. 剑指 Offer II 004. 只出现一次的数字 

3. 260. 只出现一次的数字 III
```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        if(nums.size()==2)
            return nums;

        // 找出a^b
        int eor = 0;
        for(int x: nums)
            eor ^= x;

        // 提取最右侧的1
        int rightOne = eor==INT_MIN ? eor : eor & (~eor + 1);

        int a = 0;
        for(int cur: nums) {
            // 找出其中的一个数
            if((cur & rightOne) == 0) {
                // 不停异或是因为有可能有其他数字cur & rightOne 也会等于0
                // 全部异或结束保证去重只剩下a或者b
                a ^= cur;
            }
        }
        int b = eor ^ a;
        return vector<int>{a, b};
    }
};
```

##### 21. 链表
剑指 Offer II 027. 回文链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        

        // return fun1(head);
        return fun2(head);
    }
    // reverse
    bool fun2(ListNode* head) {
        if(!head->next) return true;
        else if(!head->next->next) return head->val == head->next->val;

        ListNode* rootHead = head;
        // 快指针走完
        ListNode* slow = head;
        ListNode* fast = head;

        while(fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        // 确定需要翻转的head位置
        slow = fast->next == nullptr ? slow : slow->next;

        // 翻转后半部比较
        ListNode* reversedHead = reverse(slow);
        // 回复翻转的头节点
        // ListNode* temp = reversedHead;
        
        while(reversedHead) {
            if(head->val != reversedHead->val)
                return false;
            head = head->next;
            reversedHead = reversedHead->next;
        }

        // 翻转回复
        // reverse(temp);
        // while(rootHead) {
        //     cout << rootHead->val << ' ';
        //     rootHead = rootHead->next;
        // }

        return true;
    }
    ListNode* reverse(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* next = nullptr;
        while(head) {
            next = head->next;
            head->next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
    // stack
    bool fun1(ListNode* head) {
        if(!head->next) {
            return true;
        }
        else if(!head->next->next) {
            if(head->val != head->next->val)
                return false;
            else
                return true;
        }

        stack<int> st;
        st.push(head->val);
        ListNode* slow = head;
        ListNode* fast = head;

        while(fast->next && fast->next->next) {
            
            slow = slow->next;
            fast = fast->next->next;
            st.push(slow->val);
        }

        slow = slow->next;
        if(fast->next == nullptr)
            st.pop();
        while(slow != nullptr) {
            int value = st.top();
            if(value != slow->val) {
                return false;
            }
            st.pop();
            slow = slow->next;
        }
            
        return true;
    }
};
```

剑指 Offer 35. 复杂链表的复制
```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        // return fun1(head);

        return fun2(head);
    }

    // hash map
    Node* fun1(Node* head) {
        unordered_map<Node*, Node*> umap;
        Node* cur = head;
        while(cur) {
            umap[cur] = new Node(cur->val);
            cur = cur->next;
        }

        cur = head;
        while(cur) {
            // umap[cur] 是新节点node
            // umap[cur]->next 是新节点node->next
            // umap[cur->next] 对应新生成的cur->next节点
            umap[cur]->next = umap[cur->next];
            umap[cur]->random = umap[cur->random];

            // 会指向旧指针
            // umap[cur]->next = cur->next;
            // umap[cur]->random = cur->random;
            cur = cur->next;
        }
        return umap[head];
    }

    // without hash map
    // 1. 每个原节点->next = 新节点
    // 2. 每个新节点->rand = 原节点->rand->next
    // 3. 分离链表节点 每个原节点->next = 新节点（每个原节点->next）->next
    Node* fun2(Node* head) {

        if(!head) return head;

        Node* cur = head;

        // 创建新节点链接在旧节点之后
        while(cur) {
            Node* temp = cur->next;
            Node* newNode = new Node(cur->val);
            cur->next = newNode;
            newNode->next = temp;
            cur = newNode->next;
        }

        cur = head;

        // 设置新节点的random
        while(cur) {
            // 新节点的random
            // 判断旧节点的random是否为空
            cur->next->random = cur->random == nullptr ? nullptr : cur->random->next;
            cur = cur->next->next;
        }

        cur = head;
        Node* res = head->next;
        Node* newHead = head->next;

        // Node* test = head;
        // while(test) {
        //     cout << test->val << "->";
        //     test = test->next;
        // }

        // 分离链表
        while(cur) {
            cur->next = cur->next->next;
            // newHead->next = newHead->next->next;
            // 判断尾节点情况
            newHead->next = newHead->next == nullptr ? nullptr : newHead->next->next;

            cur = cur->next;
            newHead = newHead->next;
        }

        return res;

    }
};
```

剑指 Offer II 022. 链表中环的入口节点
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        // return fun1(head);
        return fun2(head);
    }
    // set
    ListNode* fun1(ListNode* head) {
        if(!head || !head->next) return nullptr;

        unordered_set<ListNode*> uset;
        while(head) {
            if(uset.count(head) == 0) {
                uset.insert(head);
                head = head->next;
            }
            else
                return head;
        }
        return head;
    }

    // 快慢指针
    ListNode* fun2(ListNode* head) {
        if(!head || !head->next) return nullptr;

        ListNode* slow = head;
        ListNode* fast = head;

        ListNode* temp = nullptr;
        // 注意先next再next->next防止空指针
        while(fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast) {
                temp = slow;
                break;
            }
        }

        // 无环
        if(!temp) {
            return nullptr;
        }
        // 有环
        else {
            fast = head;
            while(slow != fast) {
                slow = slow->next;
                fast = fast->next;
            }
            return fast;
        }
    }
};
```
面试题 02.07. 链表相交
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        return fun1(headA, headB);
    }

    ListNode* fun1(ListNode* h1, ListNode* h2) {
        if(!h1 && !h2)
            return nullptr;
        if(!h1 || !h2)
            return nullptr;

        // 2个链表分别走到末尾判断是否相等
        ListNode* p1 = h1;
        ListNode* p2 = h2;
        int n1 = 0;
        int n2 = 0;
        while(p1) {
            n1++;
            p1 = p1->next;
        }
        while(p2) {
            n2++;
            p2 = p2->next;
        }
        // 不相交
        if(p1 != p2) {
            return nullptr;
        }
        else {
            // 区分长短链表
            p1 = n1 > n2 ? h1 : h2;
            p2 = p1 == h1 ? h2 : h1;

            // 长链表先走
            int step = abs(n1-n2);
            while(step--) {
                p1 = p1->next;
            }

            // 一起走
            while(p1 != p2) {
                p1 = p1->next;
                p2 = p2->next;
            }
            return p1;
        }
    }
};
```

2个单链表是否相交？包含环的情况。
返回第一个相交节点
> 1. 若loop1 == loop2 == nullptr
> 只有2种情况。
> a: 两个链表不相交，两条单独链表
> b: 两个链表相交，Y字形状
> 2. 若有一个有环一个无环
> 不相交
> 3. 两个都有环
> a: 两个链表各自独立 形如 6 6
> b: 共用环只有一个相交节点 形如 Y + 6 Y的尾部接6的头部
> c: 共用环有2个相交节点 形如 b + d b和d的圈部共用
```java
public static mainFunction(Node head1, Node head2) {
    if(head1 == null || head2 == null)
        return null;
    Node loop1 = getLoopNode(head1);
    Node loop2 = getLoopNode(head2);
    // 情况1
    if(loop1 == null && loop2 == null)
        return noLoop(head1, head2);
    // 情况3
    if(loop1 != null && loop2 != null)
        return bothLoop(loop1, loop2, head1, head2);

    // 情况2
    return null;
}
```

##### 22. 二叉树
