# 面试题
#### 初
##### 1. 从1-5随机到1-7随机
> 条件函数f() 返回1-5，求目标函数g()
> 得到函数0-1范围如下：
```cpp
int zeroToOne() {
    random_device rd;
    default_random_engine generator(rd());
    uniform_int_distribution distribution(1, 5);
    int ans = 3;
    while (ans == 3) {
        ans = distribution(generator);
    }
    return ans > 3 ? 1 : 0;
}
```
> 得到函数0-7范围如下：
```cpp
// 得到000-111做到等概率
int zeroToSeven() {
    int ans = (zeroToOne() << 2) + (zeroToOne() << 1) + zeroToOne();
    return ans;
}
```
> 得到1-7范围如下：
```cpp
int oneToSix() {
    int ans = 7;
    // 如果是7重新随机
    while(ans == 7) {
        ans = zeroToSeven();
    }
    // ans [0-6]

    // 返回结果[1-7]
    return ans + 1;
}
```

##### 2. 从a-b随机到c-d随机
> - 从给定f函数做出0-1发生器
> - 0-1发生器找出 d-c 是几位二进制。比如 1-7 范围需要0-6范围+1， 0-6范围需要3个二进制位
> - 由c-d范围做出函数找到 0~（d-c）范围之后+c即可

##### 3. 01不等概率随机到01等概率随机
```cpp
// 不等概率的随机数
int f1() {
    uniform_real_distribution<double> distribution(0, 1);
    double d = distribution(generator);
    return d < 0.85 ? 0 : 1;
}
```
```cpp
// 等概率返回01
int zeroToOneEql(){
    int ans = 0;
    do {
        ans = f1();
    } while (ans == f1());
    // 两次结果不相同的概率相同
    // 0.15 * 0.85 ===> 1 0
    // 0.85 * 0.15 ===> 0 1
    return ans;
}
```

##### 4. LeetCode25. K 个一组翻转链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* start = head;
        ListNode* end = getK(start, k);

        head = end;
        reverse(start, end);

        ListNode* lastEnd = start;
        while(lastEnd->next != nullptr) {
            start = lastEnd->next;
            end = getK(start, k);
            if(end==nullptr)
                return head;
            reverse(start, end);
            lastEnd->next = end;
            lastEnd = start;
        }

        return head;
    }

    ListNode* getK(ListNode* head, int k) {
        while(--k!=0 && head!=nullptr) {
            head = head->next;
        }

        return head;
    }

    void reverse(ListNode* start, ListNode* end) {
        end = end->next;
        ListNode* pre = nullptr;
        ListNode* cur = start;
        ListNode* next = nullptr;
        while(cur != end) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        start->next = end;
    }
};
```

##### 5. LeetCode2. 两数相加
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 找出长短链表
        ListNode* ll = listLength(l1) >= listLength(l2) ? l1 : l2;
        ListNode* sl = (ll==l1) ? l2 : l1;
        ListNode* curL = ll;
        ListNode* curS = sl;
        //分三种情况分析
        ListNode* lastNode = nullptr;
        //1. 长链表和短链表都未到尾部
        int carry = 0;
        int num = 0;
        while(curS != nullptr) {
            num = curS->val + curL->val + carry;
            carry = num / 10;
            curL->val = num % 10;
            lastNode = curL;
            curL = curL->next;
            curS = curS->next;
        }
        //2. 只有长链表
        while(curL != nullptr) {
            num = curL->val + carry;
            carry = num / 10;
            curL->val = num % 10;
            lastNode = curL;
            curL = curL->next;
        }
        //3. 最后结果是否有进位
        if(carry!=0) {
            lastNode->next = new ListNode(1);
        }
        return ll;
    }

    int listLength(ListNode* head) {
        int len = 0;
        while(head != nullptr) {
            len++;
            head = head->next;
        }
        return len;
    }
};
```

##### 6. LeetCode21. 合并两个有序链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(list1==nullptr || list2==nullptr)
            return list1==nullptr ? list2 : list1;

        // 找出小头作为最终返回，不动
        ListNode* head = (list1->val <= list2->val) ? list1 : list2;
        // 准备c1作为较小头链表的第二个节点
        ListNode* c1 = head->next;
        // 准备c2作为较大头链表的第一个节点
        ListNode* c2 = head == list1 ? list2 : list1;
        // pre 作为开始比较的第一个节点初始为head
        // pre 每次更新首先指向下一个小的值，然后移动pre等待下次更新
        ListNode* pre = head;
        while(c1!=nullptr && c2!=nullptr) {
            if(c1->val <= c2->val) {
                pre->next = c1;
                c1 = c1->next;
            }
            else {
                pre->next = c2;
                c2 = c2->next;
            }
            pre = pre->next;
        }
        // 当有一方链表走到末尾
        pre->next = c1==nullptr ? c2: c1;
        
        return head;
    }
};
```

##### 6. 位图
- 一个int 32位可以表示0~31个数
- 好处：压缩空间
- 实现
```cpp
class BitMap{
long* bits;

public:
    BitMap(int max) {
        bits = new long[(max + 64) >> 6];
    }
    ~BitMap() {
        delete[] bits;
    }

    void add(int num) {
        bits[num>>6] |= (1l << (num&63));
    }

    void remove(int num) {
        bits[num>>6] &= ~(1l << (num&63));
    }

    bool contains(int num) {
        return ((bits[num>>6]) & (1l << (num&63))) != 0;
    }
};
```
- 加减乘除
```cpp
int add(int x, int y) {
    int sum = x;
    while(y != 0) {
        // 异或运算,无进位相加
        sum = x ^ y;
        // 与运算找进位，进位信息
        y = (x&y) << 1;
        // 无进位相加信息
        x = sum;
    }
    return sum;
}
```
```cpp
int neg(int x, int y) {
    return add(x, add(~y, 1));
}
```
```cpp

int multi(int x, int y) {
    int ans = 0;
    bool negative = false;

    if ((x < 0 && y > 0) || (x > 0 && y < 0)) {
        negative = true;
    }

    if (x < 0) {
        x = neg(0, x);  // 取负数的绝对值
    }

    if (y < 0) {
        y = neg(0, y);  // 取负数的绝对值
    }

    while (y != 0) {
        if (y & 1) {
            ans = add(ans, x);
        }
        x <<= 1;
        y >>= 1;
    }

    if (negative) {
        ans = neg(0, ans);  // 将结果转换回原来的符号表示
    }

    return ans;
}
```
除法
```cpp
int add(int x, int y) {
    int sum = x;
    while(y != 0) {
        // 异或运算
        sum = x ^ y;
        // 与运算找进位
        y = (x&y) << 1;
        x = sum;
    }
    return sum;
}

int neg(int x, int y) {
    return add(x, add(~y, 1));
}

int mult(int x, int y) {
    int ans = 0;
    bool negative = false;

    if ((x < 0 && y > 0) || (x > 0 && y < 0)) {
        negative = true;
    }

    if (x < 0) {
        x = neg(0, x);  // 取负数的绝对值
    }

    if (y < 0) {
        y = neg(0, y);  // 取负数的绝对值
    }

    while (y != 0) {
        if (y & 1) {
            ans = add(ans, x);
        }
        x <<= 1;
        y >>= 1;
    }

    if (negative) {
        ans = neg(0, ans);  // 将结果转换回原来的符号表示
    }

    return ans;
}

bool isNeg(int n) {
    return n < 0;
}

int divi(int a, int b) {
    int x = isNeg(a) ? neg(0, a) : a;
    int y = isNeg(b) ? neg(0, b) : b;
    int res = 0;

    for(int i = 30; i>=0; i=neg(i, 1)) {
        if ((x>>i) >= y) {
            res |= (1<<i);
            x = neg(x, y << i);
        }
    }
    return isNeg(a) ^ isNeg(b) ? neg(0, res) : res;

}

// 处理所有情况
// 尤其包含系统最小值INT_MIN这种情况，因为INT_MIN的绝对值比INT_MAX大1
int divide(int x, int y) {
    // 如果2个都是系统最小值返回1
    if(x==INT_MIN && y==INT_MIN)
        return 1;
    // 如果y是系统最小值返回0
    else if(y==INT_MIN)
        return 0;
    // 如果x是系统最小值
    else if(x==INT_MIN) {
        if(y==neg(0, 1))
            return INT_MAX;
        else {
            int c = divi(add(x, 1), y);
            return add(c, divi(neg(x, mult(c, y)), y));
        }
    }
    // 两个都不是系统最小值
    else {
        return divi(x, y);
    }
}
```
##### 7.LeetCode23
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* myFun(vector<ListNode*>& lists) {
        if(lists.size()==0) return nullptr;
        vector<ListNode*> newLists;
        bool flag = false;
        for(int i=0; i<lists.size(); ++i) {
            if(lists[i]!=nullptr) {
                newLists.push_back(lists[i]);
                flag = true;
            }
        }
        if(flag==false) return nullptr;


        multiset<int> mset;

        for(int i=0; i<newLists.size(); ++i) {
            ListNode* head = newLists[i];
            while(head!=nullptr) {
                mset.insert(head->val);
                head = head->next;
            }
        }
        ListNode* head = new ListNode(*mset.begin());
        ListNode* res = head;
        auto it = mset.begin();
        it++;
        for(; it!=mset.end(); ++it) {
            head->next = new ListNode(*it);
            head = head->next;
        }

        return res;
    }
    struct compNode {
        bool operator()(ListNode* n1, ListNode* n2) {
            return n1->val > n2->val;  // 使用 > 来实现最小堆
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size()==0) return nullptr;

        priority_queue<ListNode*, vector<ListNode*>, compNode> minHeap;

        for(int i=0; i<lists.size(); ++i) {
            if(lists[i]!=nullptr) {
                minHeap.push(lists[i]);
            }
        }
        if(minHeap.empty()) return nullptr;
        
        ListNode* head = minHeap.top();
        ListNode* res = head;
        minHeap.pop();
        if(head->next != nullptr)
            minHeap.push(head->next);

        while(!minHeap.empty()) {
            head->next = minHeap.top();
            head = head->next;
            minHeap.pop();
            if(head->next != nullptr)
                minHeap.push(head->next);
        }
        return res;
        // return myFun(lists);
    }
};
```
---
1. 与运算（AND）：
- 任何数与 0 进行与运算，结果都为 0。
- 任何数与 -1（全1） 进行与运算，结果不变。

2. 或运算（OR）：
- 任何数与 0 进行或运算，结果不变。
- 任何数与 -1（全1） 进行或运算，结果为 -1（全1）。

3. 非运算（NOT）：
- 0 取非运算，结果为 -1（全1）。
- -1（全1）取非运算，结果为 0。

4. 异或运算（XOR）：
- 任何数与自身进行异或运算，结果为 0。
- 任何数与 0 进行异或运算，结果不变。
- 异或运算满足交换律和结合律。

##### 8.LeetCode100
```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==nullptr ^ q==nullptr)
            return false;
        if(p==nullptr && q==nullptr)
            return true;

        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

##### 9. leetcode101
```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return isSame(root, root);
    }

    bool isSame(TreeNode* r1, TreeNode* r2) {
        if(r1==nullptr ^ r2==nullptr)
            return false;
        if(r1==nullptr && r2==nullptr)
            return true;

        return r1->val==r2->val && isSame(r1->left, r2->right) && isSame(r1->right, r2->left);
    }
};
```
##### 10. leetcode104
```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;


        return depth(root, 1);
    }

    int depth(TreeNode* root, int d) {
        if(root->left==nullptr && root->right==nullptr)
            return d;

        int l=0, r=0;
        if(root->left)
            l = depth(root->left, d+1);
        // l = 2;
        if(root->right)
            r = depth(root->right, d+1);

        return l>=r ? l : r;
    }
};
```

##### 11. leetcode105
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        
    //     return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
    // }

    // TreeNode* build(vector<int>& pre, int preB, int preE, vector<int>& in, int inB, int inE) {
    //     // 防止左树或者右树为空，范围越界
    //     if(preB>preE) return nullptr;
    //     TreeNode* head = new TreeNode(pre[preB]);
    //     if(preB==preE) return head;

    //     int find = inB;
    //     while(in[find]!=pre[preB])
    //         find++;

    //     head->left = build(pre, preB+1, preB+find-inB, in, inB, find-1);
    //     head->right = build(pre, preB+find-inB+1, preE, in, find+1, inE);
    //     return head;
        
    // }

    // 建hashmap省略find循环
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        unordered_map<int, int> map;
        for(int i=0; i<inorder.size(); ++i) {
            map[inorder[i]] = i;
        }
        return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1, map);
    }

    TreeNode* build(vector<int>& pre, int l1, int r1, vector<int>& in, int l2, int r2, unordered_map<int, int>& map) {
        if(l1>r1) return nullptr;
        TreeNode* node = new TreeNode(pre[l1]);
        if(l1==r1) {
            // node->val = pre[l1];
            return node;
        }

        int find = map[pre[l1]];
        node->left = build(pre, l1+1, l1+find-l2, in, l2, find-1, map);
        node->right = build(pre, l1+find-l2+1, r1, in, find+1, r2, map);

        return node;
    }
};
```
##### 12. leetcode107
```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> ans;
        if(root==nullptr) return ans;

        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            vector<int> data;
            while(size--) {
                TreeNode* node = que.front();
                data.push_back(node->val);
                que.pop();
                if(node->left)
                    que.push(node->left);
                if(node->right)
                    que.push(node->right);
            }
            ans.push_back(data);
        }
        reverse(ans.begin(), ans.end());

        return ans;
    }
};
```

##### 13. LeetCode110
```cpp
class Solution {
public:
    struct Info{
        int height;
        bool isBalanced;
        Info(int h, bool i): height(h), isBalanced(i) {}
    };
    bool isBalanced(TreeNode* root) {
        return fun(root).isBalanced;
    }

    Info fun(TreeNode* root) {
        if(root==nullptr) return Info(0, true);

        Info l = fun(root->left);
        Info r = fun(root->right);

        // 当次节点左右返回之后，此节点的高度为左右中最高高度+1
        int height = max(l.height, r.height) + 1;
        bool isBalanced = l.isBalanced && r.isBalanced && abs(l.height-r.height) < 2;

        return Info(height, isBalanced);

    }
};
```

##### 14. leetcode112
```cpp
class Solution {
public:
    bool isSum;
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;

        isSum = false;
        fun(root, targetSum, 0);

        return isSum;
    }

    void fun(TreeNode* root, int sum, int preSum) {
        if(root->left==nullptr && root->right==nullptr) {
            if(root->val+preSum==sum)
                isSum = true;
            return;
        }
        preSum += root->val;
        if(root->left) {
            fun(root->left, sum, preSum);
        }
        // preSum -= root->val;
        if(root->right) {
            fun(root->right, sum, preSum);
        }
    }
};
```

##### 14.leetcode 115
```cpp
class Solution {
public:
    bool isSum;
    vector<vector<int>> res;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(!root) return res;
        vector<int> v;

        fun(root, targetSum, 0, v);

        return res;
    }
    void fun(TreeNode* root, int sum, int preSum, vector<int>& v) {
        if(!root->left && !root->right) {
            // v.push_back(root->val);
            if(root->val + preSum == sum) {
                v.push_back(root->val);
                res.push_back(v);
                v.pop_back();
            }
            return;
        }

        preSum += root->val;
        v.push_back(root->val);
        if(root->left)
            fun(root->left, sum, preSum, v);
        
        if(root->right)
            fun(root->right, sum, preSum, v);
        v.pop_back();
    }
};
```

##### 15.leetcode113
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(!root) return res;
        vector<int> path;

        fun(root, targetSum, 0, path);

        return res;
    }
    void fun(TreeNode* root, int sum, int preSum, vector<int>& path) {
        if(!root->left && !root->right) {
            if(preSum + root->val == sum) {
                path.push_back(root->val);
                res.push_back(path);
                path.pop_back();
            }
        }

        path.push_back(root->val);
        preSum += root->val;

        if(root->left)
            fun(root->left, sum, preSum, path);
        if(root->right)
            fun(root->right, sum, preSum, path);
        path.pop_back();
    }
};
```

##### 16.leetcode912
merge sort
```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        if(nums.size()==1) return nums;

        mergeSort(nums, 0, nums.size()-1);

        return nums;
    }


//==================================================================
    void mergeSort(vector<int>& v, int l, int r) {
        if(l==r) return;

        int m = l + (r-l)/2;

        // 左侧
        mergeSort(v, l, m);
        // 右侧
        mergeSort(v, m+1, r);

        // 排序
        merge(v, l, m, r);
    }

    void merge(vector<int>& v, int l, int m, int r) {
        int p1 = l;
        int p2 = m+1;

        // i作为help下标
        int i = 0;
        vector<int> help(r-l+1);

        while(p1<=m && p2<=r) {
            help[i++] = v[p1] <= v[p2] ? v[p1++] : v[p2++];
        }

        while(p1<=m) {
            help[i++] = v[p1++];
        }
        while(p2<=r) {
            help[i++] = v[p2++];
        }

        for(int j=0; j<help.size(); ++j) {
            v[l + j] = help[j];
        }
    }
};
```

##### 17 Morris遍历
```cpp
void morris(TreeNode* head) {
    if(head==nullptr)
        return head;
    TreeNode* cur = head;
    TreeNode* mostRight = nullptr;
    while(cur) {
        mostRight = cur->left;
        if(mostRight) {
            while(mostRight->right && mostRight->right != cur) {
                mostRight = mostRight->right;
            }
            if(!mostRight->right) {
                mostRight->right = cur;
                cur = cur->left;
                continue;
            }
            else {
                mostRight->right = nullptr;
            }
        }
        cur = cur->right;
    }
}
```
##### 18. 各种排序
1. 选择排序 O(n^2)
2. 冒泡排序 O(n^2)
3. 插入排序 O(n^2)
4. 归并排序 O(n*log(n))

| 排序比较 | 时间复杂度 | 空间复杂度 | 稳定性 |
|:------:|:------:|:------:|:------:|
| 选择排序 | O(n^2^) | O(1) | 不稳定 |
| 冒泡排序 | O(n^2^) | O(1) | 稳定  |
| 插入排序 | O(n^2^) | O(1) | 稳定  |
| 归并排序 | O(n*log(n)) | O(n) | 稳定 |
| **快速排序(随机)** | O(n*log(n)) | O(log(n)) | 不稳定 |
| 堆排序   | O(n*log(n)) | O(1) | 不稳定 |

> 结论: 基于比较的排序
> 时间复杂度没有低于 N*logN
> 在空间复杂度为O(N*logN)时，没有低于O(N)空间复杂度的排序


##### 19. 有序数组二分查找
```cpp
int process(vector<int>& v, int l, int r) {
    if (l==r) return v[l];
    int mid = l + (r-l)>>1;
    int leftMax = process(v, l, mid);
    int rightMax = process(v, mid+1, r);

    return max(leftMax，rightMax);
}
```


##### 20. 异或
1. 136. 只出现一次的数字
   
2. 剑指 Offer II 004. 只出现一次的数字 

3. 260. 只出现一次的数字 III
```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        if(nums.size()==2)
            return nums;

        // 找出a^b
        int eor = 0;
        for(int x: nums)
            eor ^= x;

        // 提取最右侧的1
        int rightOne = eor==INT_MIN ? eor : eor & (~eor + 1);

        int a = 0;
        for(int cur: nums) {
            // 找出其中的一个数
            if((cur & rightOne) == 0) {
                // 不停异或是因为有可能有其他数字cur & rightOne 也会等于0
                // 全部异或结束保证去重只剩下a或者b
                a ^= cur;
            }
        }
        int b = eor ^ a;
        return vector<int>{a, b};
    }
};
```

##### 21. 链表
剑指 Offer II 027. 回文链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        

        // return fun1(head);
        return fun2(head);
    }
    // reverse
    bool fun2(ListNode* head) {
        if(!head->next) return true;
        else if(!head->next->next) return head->val == head->next->val;

        ListNode* rootHead = head;
        // 快指针走完
        ListNode* slow = head;
        ListNode* fast = head;

        while(fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        // 确定需要翻转的head位置
        slow = fast->next == nullptr ? slow : slow->next;

        // 翻转后半部比较
        ListNode* reversedHead = reverse(slow);
        // 回复翻转的头节点
        // ListNode* temp = reversedHead;
        
        while(reversedHead) {
            if(head->val != reversedHead->val)
                return false;
            head = head->next;
            reversedHead = reversedHead->next;
        }

        // 翻转回复
        // reverse(temp);
        // while(rootHead) {
        //     cout << rootHead->val << ' ';
        //     rootHead = rootHead->next;
        // }

        return true;
    }
    ListNode* reverse(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* next = nullptr;
        while(head) {
            next = head->next;
            head->next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
    // stack
    bool fun1(ListNode* head) {
        if(!head->next) {
            return true;
        }
        else if(!head->next->next) {
            if(head->val != head->next->val)
                return false;
            else
                return true;
        }

        stack<int> st;
        st.push(head->val);
        ListNode* slow = head;
        ListNode* fast = head;

        while(fast->next && fast->next->next) {
            
            slow = slow->next;
            fast = fast->next->next;
            st.push(slow->val);
        }

        slow = slow->next;
        if(fast->next == nullptr)
            st.pop();
        while(slow != nullptr) {
            int value = st.top();
            if(value != slow->val) {
                return false;
            }
            st.pop();
            slow = slow->next;
        }
            
        return true;
    }
};
```

剑指 Offer 35. 复杂链表的复制
```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        // return fun1(head);

        return fun2(head);
    }

    // hash map
    Node* fun1(Node* head) {
        unordered_map<Node*, Node*> umap;
        Node* cur = head;
        while(cur) {
            umap[cur] = new Node(cur->val);
            cur = cur->next;
        }

        cur = head;
        while(cur) {
            // umap[cur] 是新节点node
            // umap[cur]->next 是新节点node->next
            // umap[cur->next] 对应新生成的cur->next节点
            umap[cur]->next = umap[cur->next];
            umap[cur]->random = umap[cur->random];

            // 会指向旧指针
            // umap[cur]->next = cur->next;
            // umap[cur]->random = cur->random;
            cur = cur->next;
        }
        return umap[head];
    }

    // without hash map
    // 1. 每个原节点->next = 新节点
    // 2. 每个新节点->rand = 原节点->rand->next
    // 3. 分离链表节点 每个原节点->next = 新节点（每个原节点->next）->next
    Node* fun2(Node* head) {

        if(!head) return head;

        Node* cur = head;

        // 创建新节点链接在旧节点之后
        while(cur) {
            Node* temp = cur->next;
            Node* newNode = new Node(cur->val);
            cur->next = newNode;
            newNode->next = temp;
            cur = newNode->next;
        }

        cur = head;

        // 设置新节点的random
        while(cur) {
            // 新节点的random
            // 判断旧节点的random是否为空
            cur->next->random = cur->random == nullptr ? nullptr : cur->random->next;
            cur = cur->next->next;
        }

        cur = head;
        Node* res = head->next;
        Node* newHead = head->next;

        // Node* test = head;
        // while(test) {
        //     cout << test->val << "->";
        //     test = test->next;
        // }

        // 分离链表
        while(cur) {
            cur->next = cur->next->next;
            // newHead->next = newHead->next->next;
            // 判断尾节点情况
            newHead->next = newHead->next == nullptr ? nullptr : newHead->next->next;

            cur = cur->next;
            newHead = newHead->next;
        }

        return res;

    }
};
```

剑指 Offer II 022. 链表中环的入口节点
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        // return fun1(head);
        return fun2(head);
    }
    // set
    ListNode* fun1(ListNode* head) {
        if(!head || !head->next) return nullptr;

        unordered_set<ListNode*> uset;
        while(head) {
            if(uset.count(head) == 0) {
                uset.insert(head);
                head = head->next;
            }
            else
                return head;
        }
        return head;
    }

    // 快慢指针
    ListNode* fun2(ListNode* head) {
        if(!head || !head->next) return nullptr;

        ListNode* slow = head;
        ListNode* fast = head;

        ListNode* temp = nullptr;
        // 注意先next再next->next防止空指针
        while(fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast) {
                temp = slow;
                break;
            }
        }

        // 无环
        if(!temp) {
            return nullptr;
        }
        // 有环
        else {
            fast = head;
            while(slow != fast) {
                slow = slow->next;
                fast = fast->next;
            }
            return fast;
        }
    }
};
```
面试题 02.07. 链表相交
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        return fun1(headA, headB);
    }

    ListNode* fun1(ListNode* h1, ListNode* h2) {
        if(!h1 && !h2)
            return nullptr;
        if(!h1 || !h2)
            return nullptr;

        // 2个链表分别走到末尾判断是否相等
        ListNode* p1 = h1;
        ListNode* p2 = h2;
        int n1 = 0;
        int n2 = 0;
        while(p1) {
            n1++;
            p1 = p1->next;
        }
        while(p2) {
            n2++;
            p2 = p2->next;
        }
        // 不相交
        if(p1 != p2) {
            return nullptr;
        }
        else {
            // 区分长短链表
            p1 = n1 > n2 ? h1 : h2;
            p2 = p1 == h1 ? h2 : h1;

            // 长链表先走
            int step = abs(n1-n2);
            while(step--) {
                p1 = p1->next;
            }

            // 一起走
            while(p1 != p2) {
                p1 = p1->next;
                p2 = p2->next;
            }
            return p1;
        }
    }
};
```

2个单链表是否相交？包含环的情况。
返回第一个相交节点
> 1. 若loop1 == loop2 == nullptr
> 只有2种情况。
> a: 两个链表不相交，两条单独链表
> b: 两个链表相交，Y字形状
> 2. 若有一个有环一个无环
> 不相交
> 3. 两个都有环
> a: 两个链表各自独立 形如 6 6
> b: 共用环只有一个相交节点 形如 Y + 6 Y的尾部接6的头部
> c: 共用环有2个相交节点 形如 b + d b和d的圈部共用
```java
public static mainFunction(Node head1, Node head2) {
    if(head1 == null || head2 == null)
        return null;
    Node loop1 = getLoopNode(head1);
    Node loop2 = getLoopNode(head2);
    // 情况1
    if(loop1 == null && loop2 == null)
        return noLoop(head1, head2);
    // 情况3
    if(loop1 != null && loop2 != null)
        return bothLoop(loop1, loop2, head1, head2);

    // 情况2
    return null;
}
```

##### 22. 二叉树
递归序
```cpp
void f(TreeNode* root) {
    // 1
    if(root == nullptr) return;
    // 1
    f(root->left);
    // 2
    // 2
    f(root->right);
    // 3
    // 3
}
```

迭代序
144. 二叉树的前序遍历
```cpp
class Solution {
public:
    vector<int> res;
    vector<int> preorderTraversal(TreeNode* root) {
        // fun1(root);

        fun2(root);
        return res;
    }

    // 递归
    void fun1(TreeNode* root) {
        if(!root) return;

        res.push_back(root->val);
        fun1(root->left);
        fun1(root->right);
    }

    // 迭代
    void fun2(TreeNode* root) {
        stack<TreeNode*> st;
        if(!root) return;

        st.push(root);
        // res.push_back(root->val);
        while(!st.empty()) {
            TreeNode* temp = st.top();
            st.pop();
            res.push_back(temp->val);
            if(temp->right)
                st.push(temp->right);
            if(temp->left)
                st.push(temp->left);         
        }
    }
};
```
145. 二叉树的后序遍历
```cpp
class Solution {
public:
    vector<int> res;
    vector<int> postorderTraversal(TreeNode* root) {
        fun1(root);
        return res;
    }

    // 迭代
    void fun1(TreeNode* root) {
        if(!root) return;

        stack<TreeNode*> st1;
        stack<TreeNode*> st2;

        st1.push(root);
        while(!st1.empty()) {
            TreeNode* temp = st1.top();
            st1.pop();
            st2.push(temp);
            if(temp->left) {
                st1.push(temp->left);
            }
            if(temp->right) {
                st1.push(temp->right);
            }
        }

        while(!st2.empty()) {
            TreeNode* temp = st2.top();
            res.push_back(temp->val);
            st2.pop();
        }
    }
};
```

94. 二叉树的中序遍历
```cpp
class Solution {
public:
    vector<int> res;
    vector<int> inorderTraversal(TreeNode* root) {
        fun1(root);
        return res;
    }

    // 迭代
    // 左边界进栈
    // 弹出过程中在右树重复
    void fun1(TreeNode* root) {
        if(!root) return;

        stack<TreeNode*> st;
        while(!st.empty() || root) {
            if(root) {
                st.push(root);
                root = root->left;
            }
            else {
                root = st.top();
                st.pop();
                res.push_back(root->val);
                root = root->right;
            }
        }
    }
};
```
宽度遍历
```cpp
void width(TreeNode *root) {
    if(!root) return;

    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()) {
        TreeNode* node = q.top();
        q.pop();
        cout << node->val << endl;
        if(node->left)
            q.push(node->left);
        if(node->right)
            q.push(node->right);
    }
}
```

102. 二叉树的层序遍历
```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> levelOrder(TreeNode* root) {
        fun(root);
        return res;
    }

    void fun(TreeNode* root) {
        if(!root) return;

        queue<TreeNode*> q;
        q.push(root);

        while(!q.empty()) {
            int size = q.size();
            vector<int> v;
            while(size--) {
                TreeNode* temp = q.front();
                q.pop();
                v.push_back(temp->val);
                if(temp->left)
                    q.push(temp->left);
                if(temp->right)
                    q.push(temp->right);
            }
            res.push_back(v);
        }
    }
};
```
958. 二叉树的完全性检验
```cpp
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        return isCT(root);
    }

    // 层序遍历
    // 1. 任意节点有you无左false
    // 2. 满足1的情况下后序所有节点必须是叶节点
    bool isCT(TreeNode* root) {
        // if(!root->left && !root->right) return true;
        queue<TreeNode*> q;
        q.push(root);

        int size = 0;
        bool leaf = false;
        TreeNode* temp = nullptr;
        while(!q.empty()) {
            temp = q.front();
            q.pop();
            if((leaf && (temp->left || temp->right)) || (!temp->left && temp->right))
                return false;
            
            if(temp->left)
                q.push(temp->left);
            if(temp->right)
                q.push(temp->right);

            if(!temp->left || !temp->right)
                leaf = true;

        }
        return true;

    }
};
```
---
##### 套路解法: 可以解决一切树形DP问题（二叉树最难题目）
110. 平衡二叉树
```cpp
class Solution {
public:
    struct Info{
        int height;
        bool isBST;
        Info(int h, int i): height(h), isBST(i) {}
    };
    bool isBalanced(TreeNode* root) {
        return fun1(root).isBST;
    }

    Info fun1(TreeNode* root) {
        if(!root)
            return Info(0, true);

        Info leftInfo = fun1(root->left);
        Info rightInfo = fun1(root->right);

        int height = max(leftInfo.height, rightInfo.height) + 1;
        bool isBST = (leftInfo.isBST && rightInfo.isBST) && (abs(leftInfo.height - rightInfo.height) < 2);

        return Info(height, isBST);
    }
};
```
98. 验证二叉搜索树 注意释放指针
```cpp
class Solution {
public:
    struct Info{
        bool isBST;
        int max;
        int min;
        Info(bool i, int max, int min): isBST(i), max(max), min(min) {}
    };

    bool isValidBST(TreeNode* root) {
        Info* res = fun1(root);
        bool isBST = res->isBST;
        delete res;
        return isBST;
    }

    // 利用后序
    Info* fun1(TreeNode* root) {
        // base case
        if(!root)
            return nullptr;
        
        Info* leftInfo = fun1(root->left);
        Info* rightInfo = fun1(root->right);
        
        // 后序判断
        int mi = root->val;
        int ma = root->val;
        if(root->left) {
            mi = min(leftInfo->min, mi);
            ma = max(leftInfo->max, ma);
        }
        
        if(root->right) {
            mi = min(rightInfo->min, mi);
            ma = max(rightInfo->max, ma);
        }

        bool isBST = true;
        if(leftInfo && (!leftInfo->isBST || leftInfo->max >= root->val))
            isBST = false;

        if(rightInfo && (!rightInfo->isBST || rightInfo->min <= root->val))
            isBST = false;

        delete leftInfo;
        delete rightInfo;

        return new Info(isBST, ma, mi);
    }
};
```
剑指 Offer 68 - II. 二叉树的最近公共祖先
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root==p || root==q)
            return root;

        TreeNode* l = lowestCommonAncestor(root->left, p, q);
        TreeNode* r = lowestCommonAncestor(root->right, p, q);

        if(l && r)
            return root;
        else
            // 左右树 并不都有返回值
            return l == nullptr ? r : l;
    }
};
```

---
微软 对称折纸
```cpp
void printProcess(int i, int n, bool isDown) {
    if(i > n) return;

    printProcess(i+1, n, true);
    cout << (isDown == true ? "Down " : "Up ");
    printProcess(i+1, n, false);
}
void printAll(int n) {
    printProcess(1, n, true);
}
```

##### 23. 图论
```cpp
class Node {
public:
    // 入度
    int in;
    // 出度
    int out;
    // 本身数据
    int value;
    // 到达的Node
    vector<Node*> nexts;
    // 发散出去的边
    vector<Edge*> edges;
public:
    Node(int value) {
        value = value;
        in = 0;
        out = 0;
    }
    // ~Node(){
    //     // 释放nexts
    //     for (Node* next: nexts) {
    //         delete next;
    //     }
    //     nexts.clear();
    //     // 释放edges
    //     for (Edge* edge: edges) {
    //         delete edge;
    //     }
    //     edges.clear();
    // }
};

class Edge{
public:
    int weight;
    Node* from;
    Node* to;
public:
    Edge(int weight, Node* from, Node* to): weight(weight), from(from), to(to) {}
};

class Graph {
public:
    unordered_map<int, Node*> nodes;
    unordered_set<Edge*> edges;
public:
    Graph() {}
    ~Graph() {
        // 释放nodes
        for (auto it = nodes.begin(); it != nodes.end(); ++it) {
            delete it->second;
        }
        nodes.clear();

        // 释放edges
        for (Edge* edge : edges) {
            delete edge;
        }
        edges.clear();
    }
};



Graph createGraph(vector<vector<int>>& matrix) {
    Graph* graph = new Graph();
    for(int i = 0; i < matrix.size(); i++) {
        int from = matrix[i][0];
        int to = matrix[i][1];
        int weight = matrix[i][2];

        if(graph->nodes.find(from) != graph->nodes.end())
            graph->nodes.insert(make_pair(from, new Node(from)));
        if(graph->nodes.find(to) != graph->nodes.end())
            graph->nodes.insert(make_pair(to, new Node(to)));
        
        Node* fromNode = graph->nodes[from];
        Node* toNode = graph->nodes[to];
        Edge* newEdge = new Edge(weight, fromNode, toNode);
        fromNode->nexts.push_back(toNode);
        fromNode->out++;
        toNode->in++;
        fromNode->edges.push_back(newEdge);
        graph->edges.insert(newEdge);
    }
    return *graph;
}
```

##### 24. 前缀树trie树和贪心算法
208. 实现 Trie (前缀树)
```cpp
class Trie {
public:
    struct TrieNode {
        size_t pass;
        size_t end;
        TrieNode* next[26];

        TrieNode() : pass(0), end(0) {
            memset(next, 0, sizeof(next));
        }
    };

    TrieNode* root;

    Trie() {
        root = new TrieNode();
    }

    ~Trie() {
        deleteTrie(root);
    }

    void deleteTrie(TrieNode* node) {
        if (node == nullptr)
            return;

        for (int i = 0; i < 26; i++) {
            deleteTrie(node->next[i]);
        }

        delete node;
    }

    void insert(string word) {
        if (word.empty())
            return;

        TrieNode* node = root;
        for (char c : word) {
            int index = c - 'a';
            if (node->next[index] == nullptr)
                node->next[index] = new TrieNode();
            node = node->next[index];
            node->pass++;
        }
        node->end++;
    }

    bool search(string word) {
        if (word.empty())
            return false;

        TrieNode* node = root;
        for (char c : word) {
            int index = c - 'a';
            if (node->next[index] == nullptr)
                return false;
            node = node->next[index];
        }
        return node->end > 0;
    }

    bool startsWith(string prefix) {
        if (prefix.empty())
            return false;

        TrieNode* node = root;
        for (char c : prefix) {
            int index = c - 'a';
            if (node->next[index] == nullptr)
                return false;
            node = node->next[index];
        }
        return node->pass > 0;
    }
};
/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

TODO: 图
- K算法最小生成树 无向图
> 最小边加入是否有环
> 并查集判断是否有环

- P算法

- Dijkstra算法 需要出发点，到后序每个点的最短距离
> 可以有权值为负数的边，但是不能有累加和权值为负数的环

贪心算法
huffman树，切金条
```cpp
int lessMoeny(vector<int>& v) {
    priority_queue<int, vector<int>, greater<int>> pQ;
    for (int i = 0; i < v.size(); ++i)
        pQ.push(v[i]);
    int sum = 0;
    int cur = 0;
    while (pQ.size() > 1) {
        cur = pQ.top();
        pQ.pop();
        cur += pQ.top();
        pQ.pop();
        sum += cur;
        pQ.push(cur);
    }
    return sum;
}
```

295. 数据流的中位数
```cpp
class MedianFinder {
    priority_queue<int, vector<int>, greater<int>> maxQ;
    priority_queue<int, vector<int>, less<int>> minQ;
public:
    MedianFinder() {

    }
    
    void addNum(int num) {
        if(maxQ.empty() || num <= maxQ.top()) {
            minQ.push(num);
        }
        else {
            maxQ.push(num);
        }
        if(maxQ.size() - minQ.size() == 2) {
            minQ.push(maxQ.top());
            maxQ.pop();
        }
        else if(minQ.size() - maxQ.size() == 2) {
            maxQ.push(minQ.top());
            minQ.pop();
        }
    }
    
    double findMedian() {
        int size = minQ.size() + maxQ.size();
        if(size == 1) return minQ.top();
        else {
            if(size % 2 == 0)
                return (minQ.top() + maxQ.top()) / 2.0;
            else
                return minQ.size() > maxQ.size() ? minQ.top() : maxQ.top();
        }
    }
};
```

##### 25. N皇后
TODO： N皇后

##### 26. 暴力递归
> 1. 把问题转化为规模缩小了的同类问题的子问题
> 2. 有明确的不需要继续进行递归的条件base-case
> 3. 有当得到了子问题的结果之后的决策过程
> 4. 不记录每一个子问题的解
> - 搜索问题的解，可以通过 遍历 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 搜索一个问题的所有的解 ，通过深度优先遍历的思想实现

---
与动态规划的区别
  - 共同点: 用于求解多阶段决策问题。多阶段决策问题即
    - 求解一个问题分为很多步骤（阶段）；
    - 每一个步骤（阶段）可以有多种选择。
  - 不同点
    - 动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；
    - 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。
---
汉诺塔
```cpp
class Solution {
public:
    void hanota(vector<int>& A, vector<int>& B, vector<int>& C) {
        // func(3, "left", "right", "middle");
        mov(A.size(), A, C, B);
    }
    //   (num,   from, to,    other)
    // 1. 1~i-1, from, other, to
    // 2. i,     from, to,    other
    // 3. 1~i-1, other, to,   from
    void func(int i, const string& start, const string& end, const string& other) {
        if(i == 1) {
            cout << "move 1 from " << start << " to " << end << endl;
        }
        else {
            func(i-1, start, other, end);
            cout << "move " << i << " from " << start << " to " << end << endl;
            func(i-1, other, end, start);
        }
    }

    void mov(int i, vector<int>& start, vector<int>& end, vector<int>& other) {
        if(i == 1) {
            end.push_back(start.back());
            start.pop_back();
            return;
        }
        else {
            mov(i-1, start, other, end);
            end.push_back(start.back());
            start.pop_back();
            mov(i-1, other, end, start);

        }
    }
};
```
不同的子序列 II
TODO: 不同子序列二
```cpp
```

46. 全排列
```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        if(nums.size()==1) {
            res.emplace_back(nums);
            return res;
        }
        backTrack(res, nums, 0);
        return res;
    }

    void backTrack(vector<vector<int>>& res, vector<int>& path, int start) {
        if(start == path.size()) {
            res.emplace_back(path);
            return;
        }
        for(int i=start; i<path.size(); ++i) {
            swap(path[i], path[start]);
            backTrack(res, path, start+1);
            swap(path[start], path[i]);
        }
    }
};
```
47. 全排列 II
```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        if(nums.size() == 1){
            res.emplace_back(nums);
            return res;
        }

        backTrack(nums, 0, nums.size());
        return res;
    }

    void backTrack(vector<int>& path, int depth, int size) {
        if(depth == size){
            res.emplace_back(path);
            return;
        }
        // 对应题目范围 -10 ~ 10取值
        bool isVisited[21] = {false};
        for(int i=depth; i<size; ++i) {
            if(isVisited[path[i]+10] == false) {
                isVisited[path[i]+10] = true;
                swap(path[i], path[depth]);
                backTrack(path, depth+1, size);
                swap(path[depth], path[i]);
            }
        }
    }
};
```

##### 27. 布隆过滤器 
- 内存中存存放。
- 运行失误率。白名单->黑名单
- 无删除黑名单,只有加入和查询。
  
> - 加入值
>   1. 建立一个位图[0, m-1]长度
>   2. url通过K个hash函数求值
>   3. K个hash函数结果%m
>   4. 在位图中涂黑第三步的位置
>   5. 结果加入位图的数组中
> - 查询值
>   1. urlx调用K个hash函数求值后分别%m
>   2. 结果全部为1的就是结果

> - K和m的取值问题: 类比指纹采取，每个指纹如果不是100%采取，比如30%特征量，那么就有可能不同指纹的2个30%特征位置重复会有失误率。
>   根据m和样本量指定合适的K个hash函数

<br>

面试举例：n样本量  p失误率
> 1. 是否符合上面无删除只有增加和查询的结构类型
> 2. 是否允许失误率，失误率是多少

若n = 100亿, P = 0.0001
> m = - (n * lnP) / (ln2)^2^ 约等于26G
> K = ln2 * (m / n) 约等于0.7*(m / n) 向上取整
> P = (1 - e^-(n*k)/m^)^k^

哈希一致性
> - 负载均衡。利用哈希值%数据服务器,hash key选择种类多的比如身份证。反而比如性别国家不是好的设计。
> - hash环上放机器，每一段顺时针的哈希值数据隶属某个机器，新增机器时数据迁移量不高。
>   - 1. 机器太少时无法均分。
>   - 2. 即使第一次均分，之后加入新机器负载不均衡。
>   - 解决以上问题可以用虚拟节点;保证均衡的同时还可以管理负载均衡。假如总换有3000哈希值
>     - 假设初始3个虚拟节点各1000哈希值，m1 m2 m3 均分。
>     - 则环上每一段都均匀被分配，加入新节点m4时从存在节点按比例夺取；删除节点时归还节点。

#### 提升
##### 1. 
200. 岛屿数量
```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int N = grid.size();
        int M = grid[0].size();

        int res = 0;
        for(int i=0; i<N; ++i) {
            for(int j=0; j<M; ++j) {
                if(grid[i][j] == '1') {
                    res++;
                    infect(grid, i, j, N, M);
                }
            }
        }
        return res;
    }

    void infect(vector<vector<char>>& grid, int i, int j, int N, int M) {
        // 先判断ij是否越界最后判断是否为1，否则出现越界错误
        if(i<0 || i>=N || j<0 || j>=M || grid[i][j]!='1')
            return;
        grid[i][j] = '2';
        infect(grid, i+1, j, N, M);
        infect(grid, i, j+1, N, M);
        infect(grid, i-1, j, N, M);
        infect(grid, i, j-1, N, M);
    }
};
```
如何设计上面方法的并行实现
并查集

##### KMP
- str1和str2，str1是否包含str2？返回str2在str1中的开始位置
- 如何时间复杂度O(N)完成？
- KMP全部细节和实现
  > next数组
  > 循环中的比较

1.  找出字符串中第一个匹配项的下标
```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        if(needle.size() > haystack.size()) return -1;

        int p1 = 0;
        int p2 = 0;
        vector<int> next = getNext(needle);

        while(p1<haystack.size() && p2<needle.size()) {
            if(haystack[p1] == needle[p2]) {
                p1++;
                p2++;
            }
            else if(next[p2] == -1) { // next[p2] == -1 || p2 == 0
                p1++;
            }
            else {
                p2 = next[p2];
            }
        }
        // p1或者p2越界
        return p2 == needle.size() ? p1 - p2 : -1;
    }

    vector<int> getNext(const string& str) {
        if(str.size() == 1) return vector<int> {-1};

        vector<int> next(str.size());
        next[0] = -1;
        next[1] = 0;
        int cn = 0;
        int i = 2;

        while(i < next.size()) {
            if(str[i-1] == str[cn])
                next[i++] = ++cn;
            else if(cn > 0)
                cn = next[cn];
            else
                next[i++] = 0;
        }
        return next;
    }
};
```

##### Manacher算法
- 字符串中最长回文子串长度
- 如何做到时间复杂度O(N)完成
- Manacher算法细节和实现
  > 1. 经典实现：1221  =》 #1#2#2#1#；任何字符都可以不一定是未出现的字符
  > 2. 加速方法。回文半径，回文直径，从左往右半径位置数组。
    > - a. 中心 > R :暴力扩
    > - b. 中心 < R :加速
    >   - b-1: 当前位置i的i`位置不超出LR范围
    >   - b-2: i`位置超出LR范围