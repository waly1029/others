# 面试题
#### 初
##### 1. 从1-5随机到1-7随机
> 条件函数f() 返回1-5，求目标函数g()
> 得到函数0-1范围如下：
```cpp
int zeroToOne() {
    random_device rd;
    default_random_engine generator(rd());
    uniform_int_distribution distribution(1, 5);
    int ans = 3;
    while (ans == 3) {
        ans = distribution(generator);
    }
    return ans > 3 ? 1 : 0;
}
```
> 得到函数0-7范围如下：
```cpp
// 得到000-111做到等概率
int zeroToSeven() {
    int ans = (zeroToOne() << 2) + (zeroToOne() << 1) + zeroToOne();
    return ans;
}
```
> 得到1-7范围如下：
```cpp
int oneToSix() {
    int ans = 7;
    // 如果是7重新随机
    while(ans == 7) {
        ans = zeroToSeven();
    }
    // ans [0-6]

    // 返回结果[1-7]
    return ans + 1;
}
```

##### 2. 从a-b随机到c-d随机
> - 从给定f函数做出0-1发生器
> - 0-1发生器找出 d-c 是几位二进制。比如 1-7 范围需要0-6范围+1， 0-6范围需要3个二进制位
> - 由c-d范围做出函数找到 0~（d-c）范围之后+c即可

##### 3. 01不等概率随机到01等概率随机
```cpp
// 不等概率的随机数
int f1() {
    uniform_real_distribution<double> distribution(0, 1);
    double d = distribution(generator);
    return d < 0.85 ? 0 : 1;
}
```
```cpp
// 等概率返回01
int zeroToOneEql(){
    int ans = 0;
    do {
        ans = f1();
    } while (ans == f1());
    // 两次结果不相同的概率相同
    // 0.15 * 0.85 ===> 1 0
    // 0.85 * 0.15 ===> 0 1
    return ans;
}
```

##### 4. LeetCode25. K 个一组翻转链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* start = head;
        ListNode* end = getK(start, k);

        head = end;
        reverse(start, end);

        ListNode* lastEnd = start;
        while(lastEnd->next != nullptr) {
            start = lastEnd->next;
            end = getK(start, k);
            if(end==nullptr)
                return head;
            reverse(start, end);
            lastEnd->next = end;
            lastEnd = start;
        }

        return head;
    }

    ListNode* getK(ListNode* head, int k) {
        while(--k!=0 && head!=nullptr) {
            head = head->next;
        }

        return head;
    }

    void reverse(ListNode* start, ListNode* end) {
        end = end->next;
        ListNode* pre = nullptr;
        ListNode* cur = start;
        ListNode* next = nullptr;
        while(cur != end) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        start->next = end;
    }
};
```

##### 5. LeetCode2. 两数相加
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 找出长短链表
        ListNode* ll = listLength(l1) >= listLength(l2) ? l1 : l2;
        ListNode* sl = (ll==l1) ? l2 : l1;
        ListNode* curL = ll;
        ListNode* curS = sl;
        //分三种情况分析
        ListNode* lastNode = nullptr;
        //1. 长链表和短链表都未到尾部
        int carry = 0;
        int num = 0;
        while(curS != nullptr) {
            num = curS->val + curL->val + carry;
            carry = num / 10;
            curL->val = num % 10;
            lastNode = curL;
            curL = curL->next;
            curS = curS->next;
        }
        //2. 只有长链表
        while(curL != nullptr) {
            num = curL->val + carry;
            carry = num / 10;
            curL->val = num % 10;
            lastNode = curL;
            curL = curL->next;
        }
        //3. 最后结果是否有进位
        if(carry!=0) {
            lastNode->next = new ListNode(1);
        }
        return ll;
    }

    int listLength(ListNode* head) {
        int len = 0;
        while(head != nullptr) {
            len++;
            head = head->next;
        }
        return len;
    }
};
```

##### 6. LeetCode21. 合并两个有序链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(list1==nullptr || list2==nullptr)
            return list1==nullptr ? list2 : list1;

        // 找出小头作为最终返回，不动
        ListNode* head = (list1->val <= list2->val) ? list1 : list2;
        // 准备c1作为较小头链表的第二个节点
        ListNode* c1 = head->next;
        // 准备c2作为较大头链表的第一个节点
        ListNode* c2 = head == list1 ? list2 : list1;
        // pre 作为开始比较的第一个节点初始为head
        // pre 每次更新首先指向下一个小的值，然后移动pre等待下次更新
        ListNode* pre = head;
        while(c1!=nullptr && c2!=nullptr) {
            if(c1->val <= c2->val) {
                pre->next = c1;
                c1 = c1->next;
            }
            else {
                pre->next = c2;
                c2 = c2->next;
            }
            pre = pre->next;
        }
        // 当有一方链表走到末尾
        pre->next = c1==nullptr ? c2: c1;
        
        return head;
    }
};
```

##### 6. 位图
- 一个int 32位可以表示0~31个数
- 好处：压缩空间
- 实现
```cpp
class BitMap{
long* bits;

public:
    BitMap(int max) {
        bits = new long[(max + 64) >> 6];
    }
    ~BitMap() {
        delete[] bits;
    }

    void add(int num) {
        bits[num>>6] |= (1l << (num&63));
    }

    void remove(int num) {
        bits[num>>6] &= ~(1l << (num&63));
    }

    bool contains(int num) {
        return ((bits[num>>6]) & (1l << (num&63))) != 0;
    }
};
```
- 加减乘除
```cpp
int add(int x, int y) {
    int sum = x;
    while(y != 0) {
        // 异或运算,无进位相加
        sum = x ^ y;
        // 与运算找进位，进位信息
        y = (x&y) << 1;
        // 无进位相加信息
        x = sum;
    }
    return sum;
}
```
```cpp
int neg(int x, int y) {
    return add(x, add(~y, 1));
}
```
```cpp

int multi(int x, int y) {
    int ans = 0;
    bool negative = false;

    if ((x < 0 && y > 0) || (x > 0 && y < 0)) {
        negative = true;
    }

    if (x < 0) {
        x = neg(0, x);  // 取负数的绝对值
    }

    if (y < 0) {
        y = neg(0, y);  // 取负数的绝对值
    }

    while (y != 0) {
        if (y & 1) {
            ans = add(ans, x);
        }
        x <<= 1;
        y >>= 1;
    }

    if (negative) {
        ans = neg(0, ans);  // 将结果转换回原来的符号表示
    }

    return ans;
}
```
除法
```cpp
int add(int x, int y) {
    int sum = x;
    while(y != 0) {
        // 异或运算
        sum = x ^ y;
        // 与运算找进位
        y = (x&y) << 1;
        x = sum;
    }
    return sum;
}

int neg(int x, int y) {
    return add(x, add(~y, 1));
}

int mult(int x, int y) {
    int ans = 0;
    bool negative = false;

    if ((x < 0 && y > 0) || (x > 0 && y < 0)) {
        negative = true;
    }

    if (x < 0) {
        x = neg(0, x);  // 取负数的绝对值
    }

    if (y < 0) {
        y = neg(0, y);  // 取负数的绝对值
    }

    while (y != 0) {
        if (y & 1) {
            ans = add(ans, x);
        }
        x <<= 1;
        y >>= 1;
    }

    if (negative) {
        ans = neg(0, ans);  // 将结果转换回原来的符号表示
    }

    return ans;
}

bool isNeg(int n) {
    return n < 0;
}

int divi(int a, int b) {
    int x = isNeg(a) ? neg(0, a) : a;
    int y = isNeg(b) ? neg(0, b) : b;
    int res = 0;

    for(int i = 30; i>=0; i=neg(i, 1)) {
        if ((x>>i) >= y) {
            res |= (1<<i);
            x = neg(x, y << i);
        }
    }
    return isNeg(a) ^ isNeg(b) ? neg(0, res) : res;

}

// 处理所有情况
// 尤其包含系统最小值INT_MIN这种情况，因为INT_MIN的绝对值比INT_MAX大1
int divide(int x, int y) {
    // 如果2个都是系统最小值返回1
    if(x==INT_MIN && y==INT_MIN)
        return 1;
    // 如果y是系统最小值返回0
    else if(y==INT_MIN)
        return 0;
    // 如果x是系统最小值
    else if(x==INT_MIN) {
        if(y==neg(0, 1))
            return INT_MAX;
        else {
            int c = divi(add(x, 1), y);
            return add(c, divi(neg(x, mult(c, y)), y));
        }
    }
    // 两个都不是系统最小值
    else {
        return divi(x, y);
    }
}
```
##### 7.LeetCode23
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* myFun(vector<ListNode*>& lists) {
        if(lists.size()==0) return nullptr;
        vector<ListNode*> newLists;
        bool flag = false;
        for(int i=0; i<lists.size(); ++i) {
            if(lists[i]!=nullptr) {
                newLists.push_back(lists[i]);
                flag = true;
            }
        }
        if(flag==false) return nullptr;


        multiset<int> mset;

        for(int i=0; i<newLists.size(); ++i) {
            ListNode* head = newLists[i];
            while(head!=nullptr) {
                mset.insert(head->val);
                head = head->next;
            }
        }
        ListNode* head = new ListNode(*mset.begin());
        ListNode* res = head;
        auto it = mset.begin();
        it++;
        for(; it!=mset.end(); ++it) {
            head->next = new ListNode(*it);
            head = head->next;
        }

        return res;
    }
    struct compNode {
        bool operator()(ListNode* n1, ListNode* n2) {
            return n1->val > n2->val;  // 使用 > 来实现最小堆
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size()==0) return nullptr;

        priority_queue<ListNode*, vector<ListNode*>, compNode> minHeap;

        for(int i=0; i<lists.size(); ++i) {
            if(lists[i]!=nullptr) {
                minHeap.push(lists[i]);
            }
        }
        if(minHeap.empty()) return nullptr;
        
        ListNode* head = minHeap.top();
        ListNode* res = head;
        minHeap.pop();
        if(head->next != nullptr)
            minHeap.push(head->next);

        while(!minHeap.empty()) {
            head->next = minHeap.top();
            head = head->next;
            minHeap.pop();
            if(head->next != nullptr)
                minHeap.push(head->next);
        }
        return res;
        // return myFun(lists);
    }
};
```
---
1. 与运算（AND）：
- 任何数与 0 进行与运算，结果都为 0。
- 任何数与 -1（全1） 进行与运算，结果不变。

2. 或运算（OR）：
- 任何数与 0 进行或运算，结果不变。
- 任何数与 -1（全1） 进行或运算，结果为 -1（全1）。

3. 非运算（NOT）：
- 0 取非运算，结果为 -1（全1）。
- -1（全1）取非运算，结果为 0。

4. 异或运算（XOR）：
- 任何数与自身进行异或运算，结果为 0。
- 任何数与 0 进行异或运算，结果不变。
- 异或运算满足交换律和结合律。

##### 8.LeetCode100
```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==nullptr ^ q==nullptr)
            return false;
        if(p==nullptr && q==nullptr)
            return true;

        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

##### 9. leetcode101
```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return isSame(root, root);
    }

    bool isSame(TreeNode* r1, TreeNode* r2) {
        if(r1==nullptr ^ r2==nullptr)
            return false;
        if(r1==nullptr && r2==nullptr)
            return true;

        return r1->val==r2->val && isSame(r1->left, r2->right) && isSame(r1->right, r2->left);
    }
};
```
##### 10. leetcode104
```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;


        return depth(root, 1);
    }

    int depth(TreeNode* root, int d) {
        if(root->left==nullptr && root->right==nullptr)
            return d;

        int l=0, r=0;
        if(root->left)
            l = depth(root->left, d+1);
        // l = 2;
        if(root->right)
            r = depth(root->right, d+1);

        return l>=r ? l : r;
    }
};
```

##### 11. leetcode105
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        
    //     return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
    // }

    // TreeNode* build(vector<int>& pre, int preB, int preE, vector<int>& in, int inB, int inE) {
    //     // 防止左树或者右树为空，范围越界
    //     if(preB>preE) return nullptr;
    //     TreeNode* head = new TreeNode(pre[preB]);
    //     if(preB==preE) return head;

    //     int find = inB;
    //     while(in[find]!=pre[preB])
    //         find++;

    //     head->left = build(pre, preB+1, preB+find-inB, in, inB, find-1);
    //     head->right = build(pre, preB+find-inB+1, preE, in, find+1, inE);
    //     return head;
        
    // }

    // 建hashmap省略find循环
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        unordered_map<int, int> map;
        for(int i=0; i<inorder.size(); ++i) {
            map[inorder[i]] = i;
        }
        return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1, map);
    }

    TreeNode* build(vector<int>& pre, int l1, int r1, vector<int>& in, int l2, int r2, unordered_map<int, int>& map) {
        if(l1>r1) return nullptr;
        TreeNode* node = new TreeNode(pre[l1]);
        if(l1==r1) {
            // node->val = pre[l1];
            return node;
        }

        int find = map[pre[l1]];
        node->left = build(pre, l1+1, l1+find-l2, in, l2, find-1, map);
        node->right = build(pre, l1+find-l2+1, r1, in, find+1, r2, map);

        return node;
    }
};
```
##### 12. leetcode107
```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> ans;
        if(root==nullptr) return ans;

        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            vector<int> data;
            while(size--) {
                TreeNode* node = que.front();
                data.push_back(node->val);
                que.pop();
                if(node->left)
                    que.push(node->left);
                if(node->right)
                    que.push(node->right);
            }
            ans.push_back(data);
        }
        reverse(ans.begin(), ans.end());

        return ans;
    }
};
```

##### 13. LeetCode110
```cpp
class Solution {
public:
    struct Info{
        int height;
        bool isBalanced;
        Info(int h, bool i): height(h), isBalanced(i) {}
    };
    bool isBalanced(TreeNode* root) {
        return fun(root).isBalanced;
    }

    Info fun(TreeNode* root) {
        if(root==nullptr) return Info(0, true);

        Info l = fun(root->left);
        Info r = fun(root->right);

        // 当次节点左右返回之后，此节点的高度为左右中最高高度+1
        int height = max(l.height, r.height) + 1;
        bool isBalanced = l.isBalanced && r.isBalanced && abs(l.height-r.height) < 2;

        return Info(height, isBalanced);

    }
};
```

##### 14. leetcode112
```cpp
class Solution {
public:
    bool isSum;
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;

        isSum = false;
        fun(root, targetSum, 0);

        return isSum;
    }

    void fun(TreeNode* root, int sum, int preSum) {
        if(root->left==nullptr && root->right==nullptr) {
            if(root->val+preSum==sum)
                isSum = true;
            return;
        }
        preSum += root->val;
        if(root->left) {
            fun(root->left, sum, preSum);
        }
        // preSum -= root->val;
        if(root->right) {
            fun(root->right, sum, preSum);
        }
    }
};
```

##### 14.leetcode 115
```cpp
class Solution {
public:
    bool isSum;
    vector<vector<int>> res;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(!root) return res;
        vector<int> v;

        fun(root, targetSum, 0, v);

        return res;
    }
    void fun(TreeNode* root, int sum, int preSum, vector<int>& v) {
        if(!root->left && !root->right) {
            // v.push_back(root->val);
            if(root->val + preSum == sum) {
                v.push_back(root->val);
                res.push_back(v);
                v.pop_back();
            }
            return;
        }

        preSum += root->val;
        v.push_back(root->val);
        if(root->left)
            fun(root->left, sum, preSum, v);
        
        if(root->right)
            fun(root->right, sum, preSum, v);
        v.pop_back();
    }
};
```

##### 15.leetcode113
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(!root) return res;
        vector<int> path;

        fun(root, targetSum, 0, path);

        return res;
    }
    void fun(TreeNode* root, int sum, int preSum, vector<int>& path) {
        if(!root->left && !root->right) {
            if(preSum + root->val == sum) {
                path.push_back(root->val);
                res.push_back(path);
                path.pop_back();
            }
        }

        path.push_back(root->val);
        preSum += root->val;

        if(root->left)
            fun(root->left, sum, preSum, path);
        if(root->right)
            fun(root->right, sum, preSum, path);
        path.pop_back();
    }
};
```

##### 16.leetcode912
merge sort
```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        if(nums.size()==1) return nums;

        mergeSort(nums, 0, nums.size()-1);

        return nums;
    }


//==================================================================
    void mergeSort(vector<int>& v, int l, int r) {
        if(l==r) return;

        int m = l + (r-l)/2;

        // 左侧
        mergeSort(v, l, m);
        // 右侧
        mergeSort(v, m+1, r);

        // 排序
        merge(v, l, m, r);
    }

    void merge(vector<int>& v, int l, int m, int r) {
        int p1 = l;
        int p2 = m+1;

        // i作为help下标
        int i = 0;
        vector<int> help(r-l+1);

        while(p1<=m && p2<=r) {
            help[i++] = v[p1] <= v[p2] ? v[p1++] : v[p2++];
        }

        while(p1<=m) {
            help[i++] = v[p1++];
        }
        while(p2<=r) {
            help[i++] = v[p2++];
        }

        for(int j=0; j<help.size(); ++j) {
            v[l + j] = help[j];
        }
    }
};
```

##### 17 Morris遍历
```cpp
void morris(TreeNode* head) {
    if(head==nullptr)
        return head;
    TreeNode* cur = head;
    TreeNode* mostRight = nullptr;
    while(cur) {
        mostRight = cur->left;
        if(mostRight) {
            while(mostRight->right && mostRight->right != cur) {
                mostRight = mostRight->right;
            }
            if(!mostRight->right) {
                mostRight->right = cur;
                cur = cur->left;
                continue;
            }
            else {
                mostRight->right = nullptr;
            }
        }
        cur = cur->right;
    }
}
```
##### 18. 各种排序
1. 选择排序 O(n^2)
2. 冒泡排序 O(n^2)
3. 插入排序 O(n^2)
4. 归并排序 O(n*log(n))

| 排序比较 | 时间复杂度 | 空间复杂度 | 稳定性 |
|:------:|:------:|:------:|:------:|
| 选择排序 | O(n^2^) | O(1) | 不稳定 |
| 冒泡排序 | O(n^2^) | O(1) | 稳定  |
| 插入排序 | O(n^2^) | O(1) | 稳定  |
| 归并排序 | O(n*log(n)) | O(n) | 稳定 |
| **快速排序(随机)** | O(n*log(n)) | O(log(n)) | 不稳定 |
| 堆排序   | O(n*log(n)) | O(1) | 不稳定 |

> 结论: 基于比较的排序
> 时间复杂度没有低于 N*logN
> 在空间复杂度为O(N*logN)时，没有低于O(N)空间复杂度的排序


##### 19. 有序数组二分查找
```cpp
int process(vector<int>& v, int l, int r) {
    if (l==r) return v[l];
    int mid = l + (r-l)>>1;
    int leftMax = process(v, l, mid);
    int rightMax = process(v, mid+1, r);

    return max(leftMax，rightMax);
}
```


##### 20. 异或
1. 136. 只出现一次的数字
   
2. 剑指 Offer II 004. 只出现一次的数字 

3. 260. 只出现一次的数字 III
```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        if(nums.size()==2)
            return nums;

        // 找出a^b
        int eor = 0;
        for(int x: nums)
            eor ^= x;

        // 提取最右侧的1
        int rightOne = eor==INT_MIN ? eor : eor & (~eor + 1);

        int a = 0;
        for(int cur: nums) {
            // 找出其中的一个数
            if((cur & rightOne) == 0) {
                // 不停异或是因为有可能有其他数字cur & rightOne 也会等于0
                // 全部异或结束保证去重只剩下a或者b
                a ^= cur;
            }
        }
        int b = eor ^ a;
        return vector<int>{a, b};
    }
};
```

##### 21. 链表
剑指 Offer II 027. 回文链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        

        // return fun1(head);
        return fun2(head);
    }
    // reverse
    bool fun2(ListNode* head) {
        if(!head->next) return true;
        else if(!head->next->next) return head->val == head->next->val;

        ListNode* rootHead = head;
        // 快指针走完
        ListNode* slow = head;
        ListNode* fast = head;

        while(fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        // 确定需要翻转的head位置
        slow = fast->next == nullptr ? slow : slow->next;

        // 翻转后半部比较
        ListNode* reversedHead = reverse(slow);
        // 回复翻转的头节点
        // ListNode* temp = reversedHead;
        
        while(reversedHead) {
            if(head->val != reversedHead->val)
                return false;
            head = head->next;
            reversedHead = reversedHead->next;
        }

        // 翻转回复
        // reverse(temp);
        // while(rootHead) {
        //     cout << rootHead->val << ' ';
        //     rootHead = rootHead->next;
        // }

        return true;
    }
    ListNode* reverse(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* next = nullptr;
        while(head) {
            next = head->next;
            head->next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
    // stack
    bool fun1(ListNode* head) {
        if(!head->next) {
            return true;
        }
        else if(!head->next->next) {
            if(head->val != head->next->val)
                return false;
            else
                return true;
        }

        stack<int> st;
        st.push(head->val);
        ListNode* slow = head;
        ListNode* fast = head;

        while(fast->next && fast->next->next) {
            
            slow = slow->next;
            fast = fast->next->next;
            st.push(slow->val);
        }

        slow = slow->next;
        if(fast->next == nullptr)
            st.pop();
        while(slow != nullptr) {
            int value = st.top();
            if(value != slow->val) {
                return false;
            }
            st.pop();
            slow = slow->next;
        }
            
        return true;
    }
};
```

剑指 Offer 35. 复杂链表的复制
```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        // return fun1(head);

        return fun2(head);
    }

    // hash map
    Node* fun1(Node* head) {
        unordered_map<Node*, Node*> umap;
        Node* cur = head;
        while(cur) {
            umap[cur] = new Node(cur->val);
            cur = cur->next;
        }

        cur = head;
        while(cur) {
            // umap[cur] 是新节点node
            // umap[cur]->next 是新节点node->next
            // umap[cur->next] 对应新生成的cur->next节点
            umap[cur]->next = umap[cur->next];
            umap[cur]->random = umap[cur->random];

            // 会指向旧指针
            // umap[cur]->next = cur->next;
            // umap[cur]->random = cur->random;
            cur = cur->next;
        }
        return umap[head];
    }

    // without hash map
    // 1. 每个原节点->next = 新节点
    // 2. 每个新节点->rand = 原节点->rand->next
    // 3. 分离链表节点 每个原节点->next = 新节点（每个原节点->next）->next
    Node* fun2(Node* head) {

        if(!head) return head;

        Node* cur = head;

        // 创建新节点链接在旧节点之后
        while(cur) {
            Node* temp = cur->next;
            Node* newNode = new Node(cur->val);
            cur->next = newNode;
            newNode->next = temp;
            cur = newNode->next;
        }

        cur = head;

        // 设置新节点的random
        while(cur) {
            // 新节点的random
            // 判断旧节点的random是否为空
            cur->next->random = cur->random == nullptr ? nullptr : cur->random->next;
            cur = cur->next->next;
        }

        cur = head;
        Node* res = head->next;
        Node* newHead = head->next;

        // Node* test = head;
        // while(test) {
        //     cout << test->val << "->";
        //     test = test->next;
        // }

        // 分离链表
        while(cur) {
            cur->next = cur->next->next;
            // newHead->next = newHead->next->next;
            // 判断尾节点情况
            newHead->next = newHead->next == nullptr ? nullptr : newHead->next->next;

            cur = cur->next;
            newHead = newHead->next;
        }

        return res;

    }
};
```

剑指 Offer II 022. 链表中环的入口节点
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        // return fun1(head);
        return fun2(head);
    }
    // set
    ListNode* fun1(ListNode* head) {
        if(!head || !head->next) return nullptr;

        unordered_set<ListNode*> uset;
        while(head) {
            if(uset.count(head) == 0) {
                uset.insert(head);
                head = head->next;
            }
            else
                return head;
        }
        return head;
    }

    // 快慢指针
    ListNode* fun2(ListNode* head) {
        if(!head || !head->next) return nullptr;

        ListNode* slow = head;
        ListNode* fast = head;

        ListNode* temp = nullptr;
        // 注意先next再next->next防止空指针
        while(fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast) {
                temp = slow;
                break;
            }
        }

        // 无环
        if(!temp) {
            return nullptr;
        }
        // 有环
        else {
            fast = head;
            while(slow != fast) {
                slow = slow->next;
                fast = fast->next;
            }
            return fast;
        }
    }
};
```
面试题 02.07. 链表相交
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        return fun1(headA, headB);
    }

    ListNode* fun1(ListNode* h1, ListNode* h2) {
        if(!h1 && !h2)
            return nullptr;
        if(!h1 || !h2)
            return nullptr;

        // 2个链表分别走到末尾判断是否相等
        ListNode* p1 = h1;
        ListNode* p2 = h2;
        int n1 = 0;
        int n2 = 0;
        while(p1) {
            n1++;
            p1 = p1->next;
        }
        while(p2) {
            n2++;
            p2 = p2->next;
        }
        // 不相交
        if(p1 != p2) {
            return nullptr;
        }
        else {
            // 区分长短链表
            p1 = n1 > n2 ? h1 : h2;
            p2 = p1 == h1 ? h2 : h1;

            // 长链表先走
            int step = abs(n1-n2);
            while(step--) {
                p1 = p1->next;
            }

            // 一起走
            while(p1 != p2) {
                p1 = p1->next;
                p2 = p2->next;
            }
            return p1;
        }
    }
};
```

2个单链表是否相交？包含环的情况。
返回第一个相交节点
> 1. 若loop1 == loop2 == nullptr
> 只有2种情况。
> a: 两个链表不相交，两条单独链表
> b: 两个链表相交，Y字形状
> 2. 若有一个有环一个无环
> 不相交
> 3. 两个都有环
> a: 两个链表各自独立 形如 6 6
> b: 共用环只有一个相交节点 形如 Y + 6 Y的尾部接6的头部
> c: 共用环有2个相交节点 形如 b + d b和d的圈部共用
```java
public static mainFunction(Node head1, Node head2) {
    if(head1 == null || head2 == null)
        return null;
    Node loop1 = getLoopNode(head1);
    Node loop2 = getLoopNode(head2);
    // 情况1
    if(loop1 == null && loop2 == null)
        return noLoop(head1, head2);
    // 情况3
    if(loop1 != null && loop2 != null)
        return bothLoop(loop1, loop2, head1, head2);

    // 情况2
    return null;
}
```

##### 22. 二叉树
递归序
```cpp
void f(TreeNode* root) {
    // 1
    if(root == nullptr) return;
    // 1
    f(root->left);
    // 2
    // 2
    f(root->right);
    // 3
    // 3
}
```

迭代序
144. 二叉树的前序遍历
```cpp
class Solution {
public:
    vector<int> res;
    vector<int> preorderTraversal(TreeNode* root) {
        // fun1(root);

        fun2(root);
        return res;
    }

    // 递归
    void fun1(TreeNode* root) {
        if(!root) return;

        res.push_back(root->val);
        fun1(root->left);
        fun1(root->right);
    }

    // 迭代
    void fun2(TreeNode* root) {
        stack<TreeNode*> st;
        if(!root) return;

        st.push(root);
        // res.push_back(root->val);
        while(!st.empty()) {
            TreeNode* temp = st.top();
            st.pop();
            res.push_back(temp->val);
            if(temp->right)
                st.push(temp->right);
            if(temp->left)
                st.push(temp->left);         
        }
    }
};
```
145. 二叉树的后序遍历
```cpp
class Solution {
public:
    vector<int> res;
    vector<int> postorderTraversal(TreeNode* root) {
        fun1(root);
        return res;
    }

    // 迭代
    void fun1(TreeNode* root) {
        if(!root) return;

        stack<TreeNode*> st1;
        stack<TreeNode*> st2;

        st1.push(root);
        while(!st1.empty()) {
            TreeNode* temp = st1.top();
            st1.pop();
            st2.push(temp);
            if(temp->left) {
                st1.push(temp->left);
            }
            if(temp->right) {
                st1.push(temp->right);
            }
        }

        while(!st2.empty()) {
            TreeNode* temp = st2.top();
            res.push_back(temp->val);
            st2.pop();
        }
    }
};
```

94. 二叉树的中序遍历
```cpp
class Solution {
public:
    vector<int> res;
    vector<int> inorderTraversal(TreeNode* root) {
        fun1(root);
        return res;
    }

    // 迭代
    // 左边界进栈
    // 弹出过程中在右树重复
    void fun1(TreeNode* root) {
        if(!root) return;

        stack<TreeNode*> st;
        while(!st.empty() || root) {
            if(root) {
                st.push(root);
                root = root->left;
            }
            else {
                root = st.top();
                st.pop();
                res.push_back(root->val);
                root = root->right;
            }
        }
    }
};
```
宽度遍历
```cpp
void width(TreeNode *root) {
    if(!root) return;

    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()) {
        TreeNode* node = q.top();
        q.pop();
        cout << node->val << endl;
        if(node->left)
            q.push(node->left);
        if(node->right)
            q.push(node->right);
    }
}
```

102. 二叉树的层序遍历
```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> levelOrder(TreeNode* root) {
        fun(root);
        return res;
    }

    void fun(TreeNode* root) {
        if(!root) return;

        queue<TreeNode*> q;
        q.push(root);

        while(!q.empty()) {
            int size = q.size();
            vector<int> v;
            while(size--) {
                TreeNode* temp = q.front();
                q.pop();
                v.push_back(temp->val);
                if(temp->left)
                    q.push(temp->left);
                if(temp->right)
                    q.push(temp->right);
            }
            res.push_back(v);
        }
    }
};
```
958. 二叉树的完全性检验
```cpp
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        return isCT(root);
    }

    // 层序遍历
    // 1. 任意节点有you无左false
    // 2. 满足1的情况下后序所有节点必须是叶节点
    bool isCT(TreeNode* root) {
        // if(!root->left && !root->right) return true;
        queue<TreeNode*> q;
        q.push(root);

        int size = 0;
        bool leaf = false;
        TreeNode* temp = nullptr;
        while(!q.empty()) {
            temp = q.front();
            q.pop();
            if((leaf && (temp->left || temp->right)) || (!temp->left && temp->right))
                return false;
            
            if(temp->left)
                q.push(temp->left);
            if(temp->right)
                q.push(temp->right);

            if(!temp->left || !temp->right)
                leaf = true;

        }
        return true;

    }
};
```
---
##### 套路解法: 可以解决一切树形DP问题（二叉树最难题目）
110. 平衡二叉树
```cpp
class Solution {
public:
    struct Info{
        int height;
        bool isBST;
        Info(int h, int i): height(h), isBST(i) {}
    };
    bool isBalanced(TreeNode* root) {
        return fun1(root).isBST;
    }

    Info fun1(TreeNode* root) {
        if(!root)
            return Info(0, true);

        Info leftInfo = fun1(root->left);
        Info rightInfo = fun1(root->right);

        int height = max(leftInfo.height, rightInfo.height) + 1;
        bool isBST = (leftInfo.isBST && rightInfo.isBST) && (abs(leftInfo.height - rightInfo.height) < 2);

        return Info(height, isBST);
    }
};
```
98. 验证二叉搜索树 注意释放指针
```cpp
class Solution {
public:
    struct Info{
        bool isBST;
        int max;
        int min;
        Info(bool i, int max, int min): isBST(i), max(max), min(min) {}
    };

    bool isValidBST(TreeNode* root) {
        Info* res = fun1(root);
        bool isBST = res->isBST;
        delete res;
        return isBST;
    }

    // 利用后序
    Info* fun1(TreeNode* root) {
        // base case
        if(!root)
            return nullptr;
        
        Info* leftInfo = fun1(root->left);
        Info* rightInfo = fun1(root->right);
        
        // 后序判断
        int mi = root->val;
        int ma = root->val;
        if(root->left) {
            mi = min(leftInfo->min, mi);
            ma = max(leftInfo->max, ma);
        }
        
        if(root->right) {
            mi = min(rightInfo->min, mi);
            ma = max(rightInfo->max, ma);
        }

        bool isBST = true;
        if(leftInfo && (!leftInfo->isBST || leftInfo->max >= root->val))
            isBST = false;

        if(rightInfo && (!rightInfo->isBST || rightInfo->min <= root->val))
            isBST = false;

        delete leftInfo;
        delete rightInfo;

        return new Info(isBST, ma, mi);
    }
};
```
剑指 Offer 68 - II. 二叉树的最近公共祖先
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root==p || root==q)
            return root;

        TreeNode* l = lowestCommonAncestor(root->left, p, q);
        TreeNode* r = lowestCommonAncestor(root->right, p, q);

        if(l && r)
            return root;
        else
            // 左右树 并不都有返回值
            return l == nullptr ? r : l;
    }
};
```

---
微软 对称折纸
```cpp
void printProcess(int i, int n, bool isDown) {
    if(i > n) return;

    printProcess(i+1, n, true);
    cout << (isDown == true ? "Down " : "Up ");
    printProcess(i+1, n, false);
}
void printAll(int n) {
    printProcess(1, n, true);
}
```

##### 23. 图论
```cpp
class Node {
public:
    // 入度
    int in;
    // 出度
    int out;
    // 本身数据
    int value;
    // 到达的Node
    vector<Node*> nexts;
    // 发散出去的边
    vector<Edge*> edges;
public:
    Node(int value) {
        value = value;
        in = 0;
        out = 0;
    }
    // ~Node(){
    //     // 释放nexts
    //     for (Node* next: nexts) {
    //         delete next;
    //     }
    //     nexts.clear();
    //     // 释放edges
    //     for (Edge* edge: edges) {
    //         delete edge;
    //     }
    //     edges.clear();
    // }
};

class Edge{
public:
    int weight;
    Node* from;
    Node* to;
public:
    Edge(int weight, Node* from, Node* to): weight(weight), from(from), to(to) {}
};

class Graph {
public:
    unordered_map<int, Node*> nodes;
    unordered_set<Edge*> edges;
public:
    Graph() {}
    ~Graph() {
        // 释放nodes
        for (auto it = nodes.begin(); it != nodes.end(); ++it) {
            delete it->second;
        }
        nodes.clear();

        // 释放edges
        for (Edge* edge : edges) {
            delete edge;
        }
        edges.clear();
    }
};



Graph createGraph(vector<vector<int>>& matrix) {
    Graph* graph = new Graph();
    for(int i = 0; i < matrix.size(); i++) {
        int from = matrix[i][0];
        int to = matrix[i][1];
        int weight = matrix[i][2];

        if(graph->nodes.find(from) != graph->nodes.end())
            graph->nodes.insert(make_pair(from, new Node(from)));
        if(graph->nodes.find(to) != graph->nodes.end())
            graph->nodes.insert(make_pair(to, new Node(to)));
        
        Node* fromNode = graph->nodes[from];
        Node* toNode = graph->nodes[to];
        Edge* newEdge = new Edge(weight, fromNode, toNode);
        fromNode->nexts.push_back(toNode);
        fromNode->out++;
        toNode->in++;
        fromNode->edges.push_back(newEdge);
        graph->edges.insert(newEdge);
    }
    return *graph;
}
```

##### 24. 前缀树trie树和贪心算法
208. 实现 Trie (前缀树)
```cpp
class Trie {
public:
    struct TrieNode {
        size_t pass;
        size_t end;
        TrieNode* next[26];

        TrieNode() : pass(0), end(0) {
            memset(next, 0, sizeof(next));
        }
    };

    TrieNode* root;

    Trie() {
        root = new TrieNode();
    }

    ~Trie() {
        deleteTrie(root);
    }

    void deleteTrie(TrieNode* node) {
        if (node == nullptr)
            return;

        for (int i = 0; i < 26; i++) {
            deleteTrie(node->next[i]);
        }

        delete node;
    }

    void insert(string word) {
        if (word.empty())
            return;

        TrieNode* node = root;
        for (char c : word) {
            int index = c - 'a';
            if (node->next[index] == nullptr)
                node->next[index] = new TrieNode();
            node = node->next[index];
            node->pass++;
        }
        node->end++;
    }

    bool search(string word) {
        if (word.empty())
            return false;

        TrieNode* node = root;
        for (char c : word) {
            int index = c - 'a';
            if (node->next[index] == nullptr)
                return false;
            node = node->next[index];
        }
        return node->end > 0;
    }

    bool startsWith(string prefix) {
        if (prefix.empty())
            return false;

        TrieNode* node = root;
        for (char c : prefix) {
            int index = c - 'a';
            if (node->next[index] == nullptr)
                return false;
            node = node->next[index];
        }
        return node->pass > 0;
    }
};
/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

TODO: 图
- K算法最小生成树 无向图
> 最小边加入是否有环
> 并查集判断是否有环

- P算法

- Dijkstra算法 需要出发点，到后序每个点的最短距离
> 可以有权值为负数的边，但是不能有累加和权值为负数的环

贪心算法
huffman树，切金条
```cpp
int lessMoeny(vector<int>& v) {
    priority_queue<int, vector<int>, greater<int>> pQ;
    for (int i = 0; i < v.size(); ++i)
        pQ.push(v[i]);
    int sum = 0;
    int cur = 0;
    while (pQ.size() > 1) {
        cur = pQ.top();
        pQ.pop();
        cur += pQ.top();
        pQ.pop();
        sum += cur;
        pQ.push(cur);
    }
    return sum;
}
```

295. 数据流的中位数
```cpp
class MedianFinder {
    priority_queue<int, vector<int>, greater<int>> maxQ;
    priority_queue<int, vector<int>, less<int>> minQ;
public:
    MedianFinder() {

    }
    
    void addNum(int num) {
        if(maxQ.empty() || num <= maxQ.top()) {
            minQ.push(num);
        }
        else {
            maxQ.push(num);
        }
        if(maxQ.size() - minQ.size() == 2) {
            minQ.push(maxQ.top());
            maxQ.pop();
        }
        else if(minQ.size() - maxQ.size() == 2) {
            maxQ.push(minQ.top());
            minQ.pop();
        }
    }
    
    double findMedian() {
        int size = minQ.size() + maxQ.size();
        if(size == 1) return minQ.top();
        else {
            if(size % 2 == 0)
                return (minQ.top() + maxQ.top()) / 2.0;
            else
                return minQ.size() > maxQ.size() ? minQ.top() : maxQ.top();
        }
    }
};
```

##### 25. N皇后
TODO： N皇后

##### 26. 暴力递归
> 1. 把问题转化为规模缩小了的同类问题的子问题
> 2. 有明确的不需要继续进行递归的条件base-case
> 3. 有当得到了子问题的结果之后的决策过程
> 4. 不记录每一个子问题的解
> - 搜索问题的解，可以通过 遍历 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 搜索一个问题的所有的解 ，通过深度优先遍历的思想实现

---
与动态规划的区别
  - 共同点: 用于求解多阶段决策问题。多阶段决策问题即
    - 求解一个问题分为很多步骤（阶段）；
    - 每一个步骤（阶段）可以有多种选择。
  - 不同点
    - 动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；
    - 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。
---
汉诺塔
```cpp
class Solution {
public:
    void hanota(vector<int>& A, vector<int>& B, vector<int>& C) {
        // func(3, "left", "right", "middle");
        mov(A.size(), A, C, B);
    }
    //   (num,   from, to,    other)
    // 1. 1~i-1, from, other, to
    // 2. i,     from, to,    other
    // 3. 1~i-1, other, to,   from
    void func(int i, const string& start, const string& end, const string& other) {
        if(i == 1) {
            cout << "move 1 from " << start << " to " << end << endl;
        }
        else {
            func(i-1, start, other, end);
            cout << "move " << i << " from " << start << " to " << end << endl;
            func(i-1, other, end, start);
        }
    }

    void mov(int i, vector<int>& start, vector<int>& end, vector<int>& other) {
        if(i == 1) {
            end.push_back(start.back());
            start.pop_back();
            return;
        }
        else {
            mov(i-1, start, other, end);
            end.push_back(start.back());
            start.pop_back();
            mov(i-1, other, end, start);

        }
    }
};
```
不同的子序列 II
TODO: 不同子序列二
```cpp
```

46. 全排列
```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        if(nums.size()==1) {
            res.emplace_back(nums);
            return res;
        }
        backTrack(res, nums, 0);
        return res;
    }

    void backTrack(vector<vector<int>>& res, vector<int>& path, int start) {
        if(start == path.size()) {
            res.emplace_back(path);
            return;
        }
        for(int i=start; i<path.size(); ++i) {
            swap(path[i], path[start]);
            backTrack(res, path, start+1);
            swap(path[start], path[i]);
        }
    }
};
```
47. 全排列 II
```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        if(nums.size() == 1){
            res.emplace_back(nums);
            return res;
        }

        backTrack(nums, 0, nums.size());
        return res;
    }

    void backTrack(vector<int>& path, int depth, int size) {
        if(depth == size){
            res.emplace_back(path);
            return;
        }
        // 对应题目范围 -10 ~ 10取值
        bool isVisited[21] = {false};
        for(int i=depth; i<size; ++i) {
            if(isVisited[path[i]+10] == false) {
                isVisited[path[i]+10] = true;
                swap(path[i], path[depth]);
                backTrack(path, depth+1, size);
                swap(path[depth], path[i]);
            }
        }
    }
};
```

##### 27. 布隆过滤器 
- 内存中存存放。
- 运行失误率。白名单->黑名单
- 无删除黑名单,只有加入和查询。
  
> - 加入值
>   1. 建立一个位图[0, m-1]长度
>   2. url通过K个hash函数求值
>   3. K个hash函数结果%m
>   4. 在位图中涂黑第三步的位置
>   5. 结果加入位图的数组中
> - 查询值
>   1. urlx调用K个hash函数求值后分别%m
>   2. 结果全部为1的就是结果

> - K和m的取值问题: 类比指纹采取，每个指纹如果不是100%采取，比如30%特征量，那么就有可能不同指纹的2个30%特征位置重复会有失误率。
>   根据m和样本量指定合适的K个hash函数

<br>

面试举例：n样本量  p失误率
> 1. 是否符合上面无删除只有增加和查询的结构类型
> 2. 是否允许失误率，失误率是多少

若n = 100亿, P = 0.0001
> m = - (n * lnP) / (ln2)^2^ 约等于26G
> K = ln2 * (m / n) 约等于0.7*(m / n) 向上取整
> P = (1 - e^-(n*k)/m^)^k^

哈希一致性
> - 负载均衡。利用哈希值%数据服务器,hash key选择种类多的比如身份证。反而比如性别国家不是好的设计。
> - hash环上放机器，每一段顺时针的哈希值数据隶属某个机器，新增机器时数据迁移量不高。
>   - 1. 机器太少时无法均分。
>   - 2. 即使第一次均分，之后加入新机器负载不均衡。
>   - 解决以上问题可以用虚拟节点;保证均衡的同时还可以管理负载均衡。假如总换有3000哈希值
>     - 假设初始3个虚拟节点各1000哈希值，m1 m2 m3 均分。
>     - 则环上每一段都均匀被分配，加入新节点m4时从存在节点按比例夺取；删除节点时归还节点。

#### 提升
##### 1. 
200. 岛屿数量
```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int N = grid.size();
        int M = grid[0].size();

        int res = 0;
        for(int i=0; i<N; ++i) {
            for(int j=0; j<M; ++j) {
                if(grid[i][j] == '1') {
                    res++;
                    infect(grid, i, j, N, M);
                }
            }
        }
        return res;
    }

    void infect(vector<vector<char>>& grid, int i, int j, int N, int M) {
        // 先判断ij是否越界最后判断是否为1，否则出现越界错误
        if(i<0 || i>=N || j<0 || j>=M || grid[i][j]!='1')
            return;
        grid[i][j] = '2';
        infect(grid, i+1, j, N, M);
        infect(grid, i, j+1, N, M);
        infect(grid, i-1, j, N, M);
        infect(grid, i, j-1, N, M);
    }
};
```
如何设计上面方法的并行实现
并查集

##### KMP
- str1和str2，str1是否包含str2？返回str2在str1中的开始位置
- 如何时间复杂度O(N)完成？
- KMP全部细节和实现
  > next数组
  > 循环中的比较

1.  找出字符串中第一个匹配项的下标
```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        if(needle.size() > haystack.size()) return -1;

        int p1 = 0;
        int p2 = 0;
        vector<int> next = getNext(needle);

        while(p1<haystack.size() && p2<needle.size()) {
            if(haystack[p1] == needle[p2]) {
                p1++;
                p2++;
            }
            else if(next[p2] == -1) { // next[p2] == -1 || p2 == 0
                p1++;
            }
            else {
                p2 = next[p2];
            }
        }
        // p1或者p2越界
        return p2 == needle.size() ? p1 - p2 : -1;
    }

    vector<int> getNext(const string& str) {
        if(str.size() == 1) return vector<int> {-1};

        vector<int> next(str.size());
        next[0] = -1;
        next[1] = 0;
        int cn = 0;
        int i = 2;

        while(i < next.size()) {
            if(str[i-1] == str[cn])
                next[i++] = ++cn;
            else if(cn > 0)
                cn = next[cn];
            else
                next[i++] = 0;
        }
        return next;
    }
};
```

##### Manacher算法
- 字符串中最长回文子串长度
- 如何做到时间复杂度O(N)完成
- Manacher算法细节和实现
  > 1. 经典实现：1221  =》 #1#2#2#1#；任何字符都可以不一定是未出现的字符
  > 2. 加速方法。回文半径，回文直径，从左往右半径位置数组。
    > - a. i > R :暴力扩
    > - b. i < R :加速 i:当前位置 i`对称点
    >   - b-1: i\`回文范围位置不超出LR范围 i = i\`
    >   - b-2: i`回文范围超出LR范围 i = (R-i)x2
    >   - b-3: i`回文范围刚好是L边界 需要判断R+1和i的L-1是否相等
5. 最长回文子串
```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        string str = manacherStr(s);
        int pd[str.size()];
        int c = -1; // 中心
        int r = -1; // 回文右边界的下一个位置，有效区域为r-1
        int maxLen = INT_MIN;
        // int maxIndex = 0;

        for(int i=0; i<str.size(); ++i) {
            pd[i] = r > i ? min(pd[2*c-i], r-i) : 1;

            while(i+pd[i]<str.size() && i-pd[i]>-1) {
                if(str[i+pd[i]] == str[i-pd[i]])
                    pd[i]++;
                else
                    break;
            }
            if(i+pd[i]>r) {
                r = i+pd[i];
                c = i;
            }
            maxLen = std::max(maxLen, pd[i]);
            // maxIndex = maxLen == pd[i] ? i : 1;
        }
        string resStr;
        for(int i=0; i<str.size(); ++i){
            if(pd[i] == maxLen) {
                // 最长回文子串为奇数或者偶数情况
                int index = str[i] == '#' ? (i / 2 - 1) : (i - 1) / 2;
                resStr = s.substr(index - maxLen / 2 + 1, maxLen - 1);
                break;
            }
        }
            
        return resStr;
    }

    string manacherStr(const string& s) {
        int size = s.size();
        char str[size * 2 + 1];
        int index = 0;
        for (int i = 0; i < size * 2 + 1; ++i) {
            str[i] = (i & 1) == 0 ? '#' : s[index++];
        }
        return string(str, size * 2 + 1);
    }

};
```
##### 滑动窗口 单调栈
剑指 Offer 59 - I. 滑动窗口的最大值

##### 树形dp套路 猫猫
> 1. 以某个节点为头节点的子树中，分析答案有哪些可能性，并且这种分析是以x的左子树、x的右子树、x整棵树的角度来考虑可能性。
> 2. 根据第一步的可能性分析，列出所有需要的信息
> 3. 合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构
> 4. 设计递归函数，递归函数是处理以x为头节点的情况下的答案。
>    - 包括设计递归的basecase
>    - 默认直接得到左树和右树的所有信息
>    - 把可能性做整合，并且要返回第三步的信息结构这四个小步骤

543. 二叉树的直径
- 以x节点为根节点
  - 1. x参与
    - 左树最大距离
    - 右树最大距离
  - 2. x不参与
    - 左树高 + 右树高 + 1
```cpp
class Solution {
public:
    struct Info{
        int dis;
        int height;
        Info(int d, int h): dis(d), height(h) {}
    };
    int diameterOfBinaryTree(TreeNode* root) {
        return fun(root).dis - 1;
    }
    Info fun(TreeNode* root) {
        if(!root)
            return Info(0, 0);

        Info lInfo = fun(root->left);
        Info rInfo = fun(root->right);

        int lDis = lInfo.dis;
        int rDis = rInfo.dis;
        int height = lInfo.height + rInfo.height + 1;
        int dis = max(height, max(lDis, rDis));
        int h = max(lInfo.height, rInfo.height) + 1;
        return Info(dis, h);
    }
};
```

337. 打家劫舍 III
```cpp
class Solution {
public:
    // 每个节点返回是否包含这个值
    struct Info{
        int hasThisVal;
        int hasNoThisVal;
        Info(int h, int n): hasThisVal(h), hasNoThisVal(n) {}
    };
    int rob(TreeNode* root) {
        Info info = fun(root);
        return max(info.hasThisVal, info.hasNoThisVal);
    }
    Info fun(TreeNode* root) {
        // 最后的叶节点Info
        if(!root->left && !root->right)
            return Info(root->val, 0);

        int has = root->val;
        int no = 0;

        // 获取此节点下包含和不包含的情况
        if(root->left) {
            Info info = fun(root->left);
            // 如果包含此节点则其直接孩子不能包含
            has += info.hasNoThisVal;
            // 如果不包含此节点
            //   直接孩子包含
            //   直接孩子不包含
            //   取最大值
            no += max(info.hasThisVal, info.hasNoThisVal);
        }
        if(root->right) {
            Info info = fun(root->right);
            has += info.hasNoThisVal;
            no += max(info.hasThisVal, info.hasNoThisVal);
        }
        return Info(has, no);
    }
};
```
---
##### Morris遍历-线索二叉树 遍历二叉树 时间复杂度O(N),额外空间复杂度O(1)
- 假设来到当前节点cur，开始时cur来到头节点位置
  - 1. 如果cur没有左孩子，cur向右移动 cur=cur->right
  - 2. 如果cur有左孩子，找到左子树上最右的节点mostRight
    - a. 如果mostRight的右指针指向空，让其指向cur，然后cur向左移动 cur=cur->left
    - b. 如果mostRight的右指针指向cur，让其指向nullptr，然后cur向右移动 cur=cur->right
  - 3. cur为空时遍历停止
---

##### 大数据题目解题技巧
> 1. 哈希函数可以把数据按照种类均匀分流
> 2. 布隆过滤器用于集合的建立与查询，并可以节省大量空间。但是有失误率
> 3. 一致性哈希解决数据服务器的负载管理问题
> 4. 利用并查集结构做岛问题的并行计算
> 5. 位图解决某一范围上数字的出现情况，并可以节省大量空间
> 6. 利用分段统计思想，并进一步节省大量空间
> 7. 利用堆，外排序来做多个处理单元的结果合并

---

#### 位运算
##### 两个有符号32位整数ab，不用比较返回较大的数
```cpp
int flip(int n) {
    return n ^ 1;
}

int sign(int n) {
    return flip( (n >> 31) & 1 );
}

int getMax1(int a, int b) {
    int c = a - b; // 有可能溢出
    int scA = sign(c);
    int scB = flip(scA);
    return a * scA + b * scB;
}

int getMax2(int a, int b) {
    int c = a - b;
    // 记录符号位
    int sa = sign(a);
    int sb = sign(b);
    int sc = sign(c);
    // ab符号一样为0 不一样为1
    int difSab = sa ^ sb;
    // ab符号一样为1 不一样为0
    int sameSab = flip(disSab);
    int returnA = difSab * sa + sameSab * sc;
    int returnB = flip(returnA);
    return a * returnA + b * returnB;
}
```

##### 判断一个32位正数是不是2的幂，4的幂
2的幂只能有一个位为1  x&(x-1) == 0;
4的幂 先判断是否只有一个1；x&(0x55555555) != 0;

##### 有符号32位整数ab，实现加减乘除
- ^      无进位相加 a
- & << 1 进位信息   b
- 循环 a和b
```cpp
int getSum(int a, int b) {
    while (b != 0) {
        unsigned int carry = (unsigned int)(a & b) << 1;
        a = a ^ b;
        b = carry;
    }
    return a;
}
int negNum(int n) {
    return getSum(~n, 1);
}

int minus(int a, int b) {
    return minus(a, negNum(b));
}
```

### 暴力递归 动态规划
---

---

### 有序表O(lgN) 项目准备
---
有序表
- 左旋和右旋
  - 左旋：头节点向哪边倒

> 平衡搜索二叉树系列：不是严格平衡性。左旋和右旋调整平衡性。
> - AVL树：任何几点高度差不超过1。
>   - 检查平衡性时机：增加或删除节点后检查平衡性。从影响节点的父节点开始检查。
>   - 四种平衡性被破坏情况：
>     - 1. LL型。左树左边过长。
>       - 右旋解决。1次。
>     - 2. RR型。右树右边过长。
>       - 左旋解决。1次。
>     - 3. LR型。左树的右树过长。
>       - 左树左旋换节点让右节点换上去；之后对父节点右旋。2次。
>     - 4. RL星。右树的左树过长。
>       - 小局部右旋，大局左旋。2次。
> - SB树
>   - 平衡性：
>     - 每棵子树的大小不小于其兄弟的子树大小。
>     - 
> - 红黑树
> ---
> 跳表 key value list<SkipList>
> - 链表指针从高向低指向其他节点。
> - 等概率返回节点的指向长度。


---

TODO ##### 滑动窗口

1139. 最大的以 1 为边界的正方形
```cpp
class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        vector<vector<int>> rightSq = rightSquare(grid);
        vector<vector<int>> downSq = downSquare(grid);
        // for(auto x: downSq) {
        //     for(auto y: x)
        //         cout << y << ' ';
        //     cout << endl;
        // }
        int row = grid.size();
        int col = grid[0].size();
        int maxBorder = -1;
        // 防止一行或一列情况
        bool flag = false;

        for(int i=0; i<row; i++) {
            for(int j=0; j<col; j++) {
                if(grid[i][j]==1)
                    flag = true;
                int border = min(rightSq[i][j], downSq[i][j]);
                while(border > 1) {
                    if(//i+border-1<row && j+border-1<col && 不用判断越界，因为right和down
                    rightSq[i+border-1][j] >= border &&
                    downSq[i][j+border-1] >= border)
                        maxBorder = max(maxBorder, border);
                        border--;
                }
            }
        }
        cout << flag << endl;
        cout << maxBorder << endl;
        return maxBorder == -1 ? (flag == true ? 1 : 0) : maxBorder*maxBorder;
    }

    // 预处理矩阵
    // 右侧连续1矩阵；右下角开始从右往左，从下往上
    vector<vector<int>> rightSquare(vector<vector<int>>& grid) {
        int row = grid.size();
        int col = grid[0].size();
        vector<vector<int>> rightSq(row, vector<int>(col));
        for(int i = row-1; i>=0; --i) {
            rightSq[i][col-1] = grid[i][col-1] == 1 ? 1 : 0;
        }
        for(int i = row-1; i>=0; --i) {
            for(int j = col-2; j>=0; --j) {
                int preOne = rightSq[i][j+1];
                if(grid[i][j] == 1) {
                    rightSq[i][j] = preOne + 1;
                }
                else
                    rightSq[i][j] = 0;
            }
        }
        return rightSq;
    }

    // 下侧连续1矩阵
    vector<vector<int>> downSquare(vector<vector<int>>& grid) {
        int row = grid.size();
        int col = grid[0].size();
        vector<vector<int>> downSq(row, vector<int>(col));
        for(int i = col-1; i>=0; --i) {
            downSq[row-1][i] = grid[row-1][i] == 1 ? 1 : 0;
        }
        for(int i = row-2; i>=0; --i) {
            for(int j = col-1; j>=0; --j) {
                int preOne = downSq[i+1][j];
                if(grid[i][j] == 1)
                    downSq[i][j] = preOne + 1;
                else
                    downSq[i][j] = 0;
            }
        }
        return downSq;
    }
};
```

470. 用 Rand7() 实现 Rand10()
```cpp
// The rand7() API is already defined for you.
// int rand7();
// @return a random integer in the range 1 to 7

class Solution {
public:
    // 使用0-1发生器生成0-9发生器
    // rand10二级制 ...1010 四位
    int rand10() {
        int res = 0;
        do{
            // 四个二进制位可以生成10。但是4位rand01取得的数字为0~15
            // 因此只需取得0~9 + 1即可获得1~10 随机返回
            // 处理 res>=10 重新随机即可
            res = (rand01()<<3) + (rand01()<<2) + (rand01()<<1) + rand01();
        }while(res >= 10);
        return res+1;
    }

    // 先用1-7得到0-1等概率发生器
    int rand01() {
        int res = 0;
        do{
            res = rand7();
        } while(res==4);
        return res < 4 ? 0 : 1;
    }
};
```

96. 不同的二叉搜索树
```cpp
class Solution {
public:
    int numTrees(int n) {
        // return process(n);
        return process2(n);
    }

    int process(int n) {
        if(n==0)
            return 1;
        if(n<=2)
            return n;
        int res = 0;
        for(int leftNum=0; leftNum<=n-1; leftNum++) {
            int leftWays = process(leftNum);
            int rightWays = process(n-1-leftNum);
            res += leftWays * rightWays;
        }
        return res;
    }
    int process2(int n) {
        if(n<2)
            return 1;
        vector<int> dp(n+1);
        dp[0] = 1;
        for(int i=1; i<n+1; i++) {
            for(int j=0; j<=i-1; j++) {
                // 左侧节点个数    右侧节点个数
                dp[i] += dp[j] * dp[i-j-1];
            }
        }
        return dp[n];
    }
};
```

20. 有效的括号
```cpp
class Solution {
public:
    bool isValid(string s) {
        // 三种不匹配的情况
        stack<char> myStack;
        if(s.size()%2!=0) return false;
        for(int i=0; i<s.size(); ++i) {
            // 按照顺序判断
            if(s[i]=='(')
                myStack.push(')');
            else if(s[i]=='[')
                myStack.push(']');
            else if(s[i]=='{')
                myStack.push('}');
            // 如果左括号都判断结束了 仍为空则肯定是右括号在左侧前面
            else if(myStack.empty())
                return false;
            else if(s[i]!=myStack.top())
                return false;
            else if(s[i]==myStack.top())
                myStack.pop();   
        }
        return myStack.empty();
    }
};
```

678. 有效的括号字符串
```cpp
class Solution {
public:
    bool checkValidString(string s) {
        if(s.size()==1){
            if(s[0]=='*')
                return true;
            else
                return false;
        }

        stack<int> leftStk;
        stack<int> starStk;
        
        for(int i=0; i<s.size(); ++i) {
            if(s[i]=='(')
                leftStk.push(i);
            else if(s[i]=='*')
                starStk.push(i);
            else {
                if(!leftStk.empty())
                    leftStk.pop();
                else {
                    if(!starStk.empty())
                        starStk.pop();
                    else
                        return false;
                }
            }
        }

        while(!starStk.empty() && !leftStk.empty()) {
            int s = starStk.top();
            starStk.pop();
            int l = leftStk.top();
            leftStk.pop();
            // 判断字符串中括号的下标位置
            if(l > s)
                return false;
        }
        // cout << leftStk.size() << endl;
        // cout << starStk.size() << endl;

        return leftStk.empty();
    }
};
```

32. 最长有效括号
```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        if(s.size()==0 || s.size()==1) return 0;

        // dp[i]:在i位置上，以）结尾的有效的长度
        vector<int> dp(s.size(), 0);

        int max = 0;
        for(int i=1; i<s.size(); ++i) {
            if(s[i]==')') {
                int pre = i - dp[i-1] - 1;
                // 如果不越界 并且是 左括号
                if(pre>=0 && s[pre]=='(')
                    dp[i] = dp[i-1] + 2 + (pre > 0 ? dp[pre-1] : 0);
            }
            max = std::max(max, dp[i]);
        }
        for(auto x: dp)
            cout << x << ',';
        return max;
    }
};
```

面试题 03.05. 栈排序
```cpp
class SortedStack {
    stack<int> st;
    stack<int> sst;
    int size;
public:
    SortedStack() {
        size = 0;
    }
    
    void push(int val) {
        // cout << "push" << endl;
        if(size==0) {
            st.push(val);
            // size++;
        }
        else {
            while(!st.empty() && st.top() <= val) {
                int temp = st.top();
                st.pop();
                sst.push(temp);
            }
            st.push(val);
            while(!sst.empty()) {
                int temp = sst.top();
                sst.pop();
                st.push(temp);
            }
        }
        size++;
        // cout << st.size() << endl;
    }
    
    void pop() {
        // cout << "pop" << endl;
        if(size > 0) {
            size--;
            st.pop();
        }
    }
    
    int peek() {
        // cout << "peek" << endl;
        return size == 0 ? -1 : st.top();
    }
    
    bool isEmpty() {
        return size == 0;
    }
};
```

240. 搜索二维矩阵 II
```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row = matrix.size()-1;
        int col = 0;

        while(row>=0 && row<matrix.size() && col>=0 && col<matrix[0].size()) {
            if(target==matrix[row][col])
                return true;
            else if(target>matrix[row][col]) {
                col++;
            }
            else if(target<matrix[row][col]) {
                row--;
            }
        }

        return false;
    }
};
```

517. 超级洗衣机
```cpp
class Solution {
public:
    int findMinMoves(vector<int>& machines) {
        int sum = 0;
        for(auto x: machines)
            sum += x;
        if(sum % machines.size() != 0)
            return -1;
        if(sum==0)
            return 0;

        int avg = sum / machines.size();
        int leftSum = 0;
        int ans = 0;
        //  左侧和     当前位置     右侧和
        // 通过比较左侧和右侧和的大小进行计算
        // 左右都是负数 abs左 + abs右
        // 左右都是正数 max(abs左， abs右)
        // 左负右正    max（abs左， abs右）
        // 左正右负...
        // 找出所有值中最大值
        for(int i=0; i<machines.size(); ++i) {
            int leftRest = leftSum - i*avg;
            int rightRest = (sum-leftSum-machines[i]) - (machines.size()-i-1)*avg;
            if(leftRest<0 && rightRest<0)
                ans = max(ans, abs(leftRest)+abs(rightRest));
            else
                ans = max(ans, max(abs(leftRest), abs(rightRest)));
            leftSum += machines[i];
        }
        return ans;
    }
};
```

692. 前K个高频单词
```cpp
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        return fun1(words, k);
    }
    // 比较器小根堆
    struct Compare{
        bool operator()(const pair<string, int>& p1, const pair<string, int>& p2) const {
            // 词频小的是堆顶
            if(p1.second != p2.second) {
                return p1.second > p2.second;
            }
            // 词频相同时按照字典序反向排列
            else
                return p1.first < p2.first;
        }
    };
    // 优先队列（小根堆保证k个）
    vector<string> fun1(vector<string>& words, int k) {
        if(words.size()==1)
            return words;

        vector<string> res(k);
        unordered_map<string, int> umap;
        priority_queue<pair<string, int>, vector<pair<string, int>>, Compare> pq;
        for(int i=0; i<words.size(); ++i) {
            umap[words[i]]++;
        }
        // for(auto it=umap.begin(); it!=umap.end(); ++it) {
        //     if(pq.size() < k) {
        //         pq.push(*it);
        //     }
        //     else {
        //         if (Compare()(*it, pq.top())) {
        //             pq.pop();
        //             pq.push(*it);
        //         }
        //     }
        // }
        for(const auto& pair: umap) {
            pq.emplace(pair);
            if(pq.size() > k)
                pq.pop();
        }

        // while(!pq.empty()) {
        //     auto temp = pq.top();
        //     pq.pop();
        //     res.insert(res.begin(), temp.first);
        // }
        for(int i=k-1; i>=0; --i) {
            res[i] = pq.top().first;
            pq.pop();
        }

        // for(auto it: umap)
        //     cout << it.first << ":" << it.second << endl;
        return res;
    }
};
```
23. 合并 K 个升序链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        
        return fun2(lists);
        // return fun1(lists);
    }
    // ========================================================
    // 小顶堆存入val -> 新建链表
    ListNode* fun2(vector<ListNode*>& lists) {
        // 筛选无效链表
        if(lists.size()==0)
            return nullptr;
        bool flag = false;
        vector<ListNode*> newLists;
        for(int i=0; i<lists.size(); ++i) {
            ListNode* head = lists[i];
            if(head) {
                newLists.push_back(lists[i]);
                flag = true;
            }
        }
        // 是否lists中所有元素都为空
        if(flag==false)
            return nullptr;

        // 小顶堆
        priority_queue<int, vector<int>, greater<int>> minPq;
        for(auto& it: newLists) {
            while(it != nullptr) {
                minPq.push(it->val);
                it = it->next;
            }
        }

        // check if the minPq is correct
        // while(!minPq.empty()) {
        //     cout << minPq.top() << ',';
        //     minPq.pop();
        // }

        // 根据小顶堆来新建链表
        ListNode* head = new ListNode(minPq.top());
        ListNode* res = head;
        minPq.pop();
        while(!minPq.empty()) {
            head->next = new ListNode(minPq.top());
            minPq.pop();
            head = head->next;
        }

        return res;
    }
    // ========================================================
    // 循环合并双链表
    ListNode* fun1(vector<ListNode*>& lists) {
        if(lists.size()==0)
            return nullptr;
        if(lists.size()==1)
            return lists[0];

        ListNode* node = lists[0];
        for(int i=1; i<lists.size(); ++i) {
            node = mergeTwoLists(node, lists[i]);
        }

        return node;
    }
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(!l1 && !l2)
            return nullptr;
        if(!l1 || !l2)
            return l1 == nullptr ? l2 : l1;

        ListNode* head1 = l1->val <= l2->val ? l1 : l2;
        ListNode* head2 = head1 == l1 ? l2 : l1;
        ListNode* cur = head1;
        head1 = head1->next;
        while(head1 && head2) {
            if(head1->val <= head2->val) {
                cur->next = head1;
                head1 = head1->next;
            }
            else {
                cur->next = head2;
                head2 = head2->next;
            }
            cur = cur->next;
        }
        if(head1)
            cur->next = head1;
        if(head2)
            cur->next = head2;
        return l1->val <= l2->val ? l1 : l2;
    }
};
```

445. 两数相加 II
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    struct Info{
        int size;
        ListNode* node;
        Info(int s, ListNode* n): size(s), node(n) {}
    };
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 翻转
        Info info1 = reverseList(l1);
        Info info2 = reverseList(l2);

        // 原地相加
        ListNode* longH = info1.size >= info2.size ? info1.node : info2.node;
        ListNode* shortH = longH == info1.node ? info2.node : info1.node;
        ListNode* res = longH;
        int carry = 0;
        // 防止链表长度相同走入空节点
        ListNode* tail = nullptr;
        // 两个链表先走完短链表 相加
        while(longH && shortH) {
            int sum = longH->val + shortH->val + carry;
            longH->val = sum % 10;
            carry = sum / 10;
            tail = longH;
            longH = longH->next;
            shortH = shortH->next;
        }

        // 继续长链表后续与进位相加
        while(longH) {
            int sum = longH->val + carry;
            longH->val = sum % 10;
            carry = sum / 10;
            tail = longH;
            longH = longH->next;
        }

        // 判断最后是否有进位
        if(carry == 1)
            tail->next = new ListNode(1);

        // 翻转
        Info resInfo = reverseList(res);

        return resInfo.node;
    }

    Info reverseList(ListNode* head) {
        if(!head->next)
            return Info(1, head);

        ListNode* pre = nullptr;
        int size = 0;
        
        while(head != nullptr) {
            ListNode* temp = head->next;
            head->next = pre;
            pre = head;
            head = temp;
            size++;
        }

        return Info(size, pre);
        
    }
};
```